
local ffi = require 'ffi';
local bit = require 'bit';
local clipboard = require "gamesense/clipboard";
local http = require "gamesense/http" or error("Missing Http library");
local vector = require 'vector' or error("Missing Vector library");
local anti_aim = require 'gamesense/antiaim_funcs' or error("Missing antiaim funcs library");
local base64 = require "gamesense/base64" or error("Missing base64 library");
local c_entity = require("gamesense/entity") or error("Missing Entity library library");
local animations = (function ()local a={data={}}function a:clamp(b,c,d)return math.min(d,math.max(c,b))end;function a:animate(e,f,g)if not self.data[e]then self.data[e]=0 end;g=g or 4;local b=globals.frametime()*g*(f and-1 or 1)self.data[e]=self:clamp(self.data[e]+b,0,1)return self.data[e]end;return a end)()
js_loadstring = panorama.loadstring([[ return { OpenExternalBrowserURL: function(url) { void SteamOverlayAPI.OpenExternalBrowserURL(url) } } ]])()
writefile("login_details.txt", "")
writefile("evade_user.txt", "")
writefile("hwid_management.txt", "")
writefile("evade_autosave.txt", "")
print("Do /load to force load pre-saved settings")
local new_tbl = {
    hp = 100,
    old_hp = 100,
    hp_status = false,
    miss = 0,
    hit = 0,
    timer = 0,
    shot = false
}

if readfile("evade_cfglist.txt") == nil then
    writefile("evade_cfglist.txt", "[]")
end
local configs = {
    list = {},
    selected = nil
}


--[[

local w, h = client.screen_size()
local alpha = 69
local toggled = false
client.set_event_callback("paint_ui", function()
	if alpha > 0 and toggled then

		alpha = alpha - 0.35
	else
		if not toggled then
			alpha = alpha + 1
			if alpha == 254 then
				toggled = true
			end
			alpha = alpha + 1
		end
	end
	if alpha > 1 then
		renderer.gradient(0,0,w,h,0,0,0,alpha,0,0,0,alpha,false)
	end
end)

]]

tbl = {}

tbl.antiaim = {
    evade_fake = false,
    autocheck = false,
    current = false,
    active = false,
    count = false,
    ready = false,
    ready1 = false,
    ready2 = false,
    timer = 0,
    fs = 0,
    last = 0,
    log = {},
    manual = {
        aa = 0,
        tick = 0,
    },

    exact_pi = 0,
    is_antiknife = false
}





local function incrementLoadCount()
    local count = database.read("evade_stats")
    if count == nil then
        count = 0
    end

    count = count + 1
    database.write("evade_stats", count)

    return count
end
local loadCount = incrementLoadCount()
local ffi = require("ffi")

ffi.cdef([[
  typedef struct _RenderAdapterInfo {
    char __m_pDriverName[512];
    unsigned int __m_VendorID;
    unsigned int __m_DeviceID;
    unsigned int __m_SubSysID;
    unsigned int __m_Revision;
    int __m_nDXSupportLevel;
    int __m_nMinDXSupportLevel;
    int __m_nMaxDXSupportLevel;
    unsigned int __m_nDriverVersionHigh;
    unsigned int __m_nDriverVersionLow;
    int64_t pad_0;
  } RenderAdapterInfo, *PRenderAdapterInfo;
]])

local RenderAdapterInfo_t = ffi.typeof("RenderAdapterInfo")

local native_get_current_adapter = vtable_bind("materialsystem.dll", "VMaterialSystem080", 25, "int(__thiscall*)(void*)")
local native_get_adapter_info = vtable_bind("materialsystem.dll", "VMaterialSystem080", 26, "void(__thiscall*)(void*, int, $*)", RenderAdapterInfo_t)

local function get_current_adapter()
    return native_get_current_adapter()
end

local function get_adapter_info(adapter)
    local info = RenderAdapterInfo_t()
    
    native_get_adapter_info(adapter, info)

    local result = {}
    result.drivername = ffi.string(info.__m_pDriverName)
    result.vendorid = tonumber(info.__m_VendorID)
    result.deviceid = tonumber(info.__m_DeviceID)
    result.subsysid = tonumber(info.__m_SubSysID)
    result.revision = tonumber(info.__m_Revision)
    result.dxsupportlevel = tonumber(info.__m_nDXSupportLevel)
    result.mindxsupportlevel = tonumber(info.__m_nMinDXSupportLevel)
    result.maxdxsupportlevel = tonumber(info.__m_nMaxDXSupportLevel)
    result.driverversionhigh = tonumber(info.__m_nDriverVersionHigh)
    result.driverversionlow = tonumber(info.__m_nDriverVersionLow)

    return json.stringify(

    result.drivername..
    result.vendorid..
    result.deviceid..
    result.subsysid..
    result.revision..
    result.dxsupportlevel..
    result.mindxsupportlevel..
    result.maxdxsupportlevel..
    result.driverversionhigh..
    result.driverversionlow

    )
end

-- Get the current adapter index
local adapter = get_current_adapter()
-- Get the adapter info as a table
local hwid = get_adapter_info(adapter)
-- Print the adapter info in a formatted way






local get_base = {

    encode = base64.encode(hwid, "base64"),
    decode = ""
}

local curr_build = "DEV"

local login_details = {
    login = "NULL",
    access = false,
    web_info = "",
    is_visible = false,
    registration_data = get_base.encode,
    is_registered = false,
    bypass_register = false,
    has_access = false
}


if readfile("hwid_management.txt") == get_base.encode then
    login_details.is_registered = true
end


--[[

local decode_button = ui.new_button("AA", "Anti-aimbot angles", "HWID PRINT", function()
    get_base.encode = (base64.encode(hwid, "base64"))
    get_base.decode = (base64.decode(get_base.encode, "base64"))

    client.color_log(255, 255, 255, "Encoded: \n"..get_base.encode.."\n Decoded: \n"..get_base.decode)
end)

]]



local play_data = {

    start_time = globals.curtime(),
    seconds = 0,
    minutes = 0,
    hours = 0,
    hits = 0,
    misses = 0,
    hm_ratio = 0,
    ticks_elapsed = 0
}


client.set_event_callback("console_input", function(text)
    if not string.find(text, "/login") then return end
    local string_len = string.len(text)
    login_details.login = string.sub(text, 8, string_len)
end)

http.get("https://raw.githubusercontent.com/QualetyWeb/qualety.github.io/main/usernames.txt", function(s, r)
    if not s or r.status ~= 200 then
        return
    end
    login_details.web_info = r.body
    
end)









local hb_tbl = {

    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19
}

local function get_camera_pos(enemy)
    local e_x, e_y, e_z = entity.get_prop(enemy, "m_vecOrigin")
    if e_x == nil then return end
    local _, _, ofs = entity.get_prop(enemy, "m_vecViewOffset")
    e_z = e_z + (ofs - (entity.get_prop(enemy, "m_flDuckAmount") * 16))
    return e_x, e_y, e_z
end

local tickshot = 0
clamp = function(x) 
    if x == nil then 
        return 0
    end 
    x = (x % 360 + 360) % 360 
    return x > 180 and x - 360 or x 
end,










-- PREDICT DEBUGGING
require( "vector3" )
local get_prop         		= entity.get_prop
local ui_get           		= ui.get
local get_local_player 		= entity.get_local_player
local get_all_players  		= entity.get_players
local get_player_weapon  	= entity.get_player_weapon
local entity_is_enemy  		= entity.is_enemy
local entity_is_alive  		= entity.is_alive
local entity_is_dormant 	= entity.is_dormant
local math_atan2 	   		= math.atan2
local math_deg 	   	   		= math.deg
local math_sqrt		   		= math.sqrt


local v_left, v_right = Vector3(0, 0, 0), Vector3(0, 0, 0)
local l_dmg, r_dmg, c_dmg = 0, 0, 0

local o_scan_fineness = 20
local o_scan_length = 10
--DEBUG END;
ffi.cdef[[
    void* __stdcall URLDownloadToFileA(void* LPUNKNOWN, const char* LPCSTR, const char* LPCSTR2, int a, int LPBINDSTATUSCALLBACK);
    bool DeleteUrlCacheEntryA(const char* lpszUrlName);

]]


local js = panorama.open()
local _ENV = getfenv(); do
    local libs = {
        { "csgo_weapons",   "18807" },
        { "http",           "19253" },
        { "trace",          "32949" },
    }
    for _, lib in ipairs(libs) do
        local success, loaded_lib = pcall(require, (lib[2] and "gamesense/" or "lib/") .. lib[1])
        if success then
            _ENV[lib[1]] = loaded_lib
        else
            if lib[2] then
                js.SteamOverlayAPI.OpenExternalBrowserURL("https://gamesense.pub/forums/viewtopic.php?id=" .. lib[2])
            else
                error("Failed to load module: lib/" .. lib[1] .. " | Local library not found in lib folder", 2)
            end
        end
    end
end
local antiaim = {}
local menu = {
    ragebot_toggle = ui.reference("RAGE", "Aimbot", "Enabled");
    enabled = ui.reference("AA", "Anti-aimbot angles", "Enabled");                                  -- [1]  Enable AA                           [29]
    pitch = {ui.reference("AA", "Anti-aimbot angles", "Pitch")};                                    -- [2]  Pitch                               [30]
    yaw_base = ui.reference("AA", "Anti-aimbot angles", "Yaw base");                                -- [3]  Yaw Base                            [31]
    yaw = { ui.reference("AA", "Anti-aimbot angles", "Yaw") },                                      -- [4]  Yaw --> drop[1], slider[2]          [32]
    yaw_jitter = { ui.reference("AA", "Anti-aimbot angles", "Yaw jitter") };                        -- [5]  Yaw Jitter                          [33]
    body_yaw = { ui.reference("AA", "Anti-aimbot angles", "Body yaw") };                            -- [6]  Body Yaw                            [34]
    freestanding_body_yaw = ui.reference("AA", "Anti-aimbot angles", "Freestanding body yaw");      -- [7]  Freestanding Body Yaw               [35]
    edge_yaw = ui.reference("AA", "Anti-aimbot angles", "Edge yaw");                                -- [8]  Edge Yaw                            [36] 
    freestand = { ui.reference("AA", "Anti-aimbot angles", "Freestanding") },                       -- [9]  Freestanding --> Ref[1], Key[2]     [37]
	roll = ui.reference("AA", "Anti-aimbot angles", "Roll");                                        -- [10] Roll                                [38]
    legmovement = ui.reference("AA", "Other", "Leg movement");                                      -- [11] Leg Movement                        [39]
    fakepeek = { ui.reference("AA", "Other", "Fake peek") },                                        -- [12] Fake Peek                           [40]
    slowmotion = { ui.reference("AA", "Other", "Slow motion") },                                    -- [13] Slow Motion                         [41]
    onshot = { ui.reference("AA", "Other", "On shot anti-aim") },                                   -- [14] OSAA / Hideshots                    [42]
    doubletap = { ui.reference("RAGE", "Aimbot", "Double tap") },                                   -- [15] Double Tap                          [43]
    fakeduck = ui.reference("RAGE", "Other", "Duck peek assist");                                   -- [16] Fake Duck                           [44]
    auto_peek = { ui.reference("Rage", "Other", "Quick peek assist") },                             -- [17] Auto Peek                           [45]
    pingspike = { ui.reference("MISC", "Miscellaneous", "Ping Spike") },                            -- [18] Ping Spike                          [46]
    fakelag = ui.reference("AA", "Fake lag", "Enabled");                                            -- [19] Fakelag Switch                      [47]
    fakelag_limit = ui.reference("AA", "Fake lag", "Limit");                                        -- [20] Fakelag Limit                       [48]
    force_body = ui.reference("RAGE", "Aimbot", "Force body aim");                                  -- [21] Force Baim                          [49]
    force_safe = ui.reference("RAGE", "Aimbot", "Force safe point");                                -- [22] Force Safepoint                     [50]
    menu_color = { ui.reference("MISC", "Settings", "Menu color") };                                -- [23] Menu Color                          [51]
    clantag = ui.reference("MISC", "Miscellaneous", "Clan tag spammer");                            -- [24] Clantag Spammer                     [52]
    damage_bind = { ui.reference('RAGE', 'Aimbot', 'Minimum damage override') };                    -- [25] Minimum Damage Override             [53]

}



client.set_event_callback("shutdown", function()
    ui.set_visible(menu.fakepeek[1], true)
    ui.set_visible(menu.fakepeek[2], true)
    ui.set_visible(menu.legmovement, true)
    ui.set_visible(menu.slowmotion[1], true)
    ui.set_visible(menu.slowmotion[2], true)
    ui.set_visible(menu.onshot[1], true)
    ui.set_visible(menu.onshot[2], true)
    ui.set_visible(menu.enabled, true)
    ui.set_visible(menu.pitch[1], true)
    ui.set_visible(menu.pitch[2], true)
    ui.set_visible(menu.yaw_base, true)
    ui.set_visible(menu.yaw[1], true)
    ui.set_visible(menu.yaw[2], true)
    ui.set_visible(menu.yaw_jitter[1], true)
    ui.set_visible(menu.yaw_jitter[2], true)
    ui.set_visible(menu.body_yaw[1], true)
    ui.set_visible(menu.body_yaw[2], true)
    ui.set_visible(menu.freestanding_body_yaw, true)
    ui.set_visible(menu.edge_yaw, true)
    ui.set_visible(menu.freestand[1], true)
    ui.set_visible(menu.freestand[2], true)
    ui.set_visible(menu.roll, true)
    ui.set_visible(menu.legmovement, true)

end)


local lp = entity.get_local_player()

states = {
	[1] = "Global",
    [2] = "Standing",
    [3] = "Running",
    [4] = "Slow Motion",
	[5] = "Air",
    [6] = "Air-Duck",
    [7] = "Duck"
}
local aa_tabs = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAnti\aE8E8E8FF-\aBBC0F3FFAim\aE8E8E8FF] ~\aE8E8E8FF Tabs", {"\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot", "\aFFDF62FF⚠ \aE8E8E8FFAnti-Bruteforce", "\aBBC0F3FF∑ \aE8E8E8FFExtra"})
local firstlabel = ui.new_label("AA", "Anti-aimbot angles", "               ~~~~~~~~~~~~~~~~\n")
local aa_type = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAnti\aE8E8E8FF-\aBBC0F3FFAim\aE8E8E8FF] ~\aE8E8E8FF Type", {"None", "Presets", "Builder"}, "Builder")
ui.set(aa_type, "Builder")






local lua = {

    home = {
        label1 = ui.new_label("AA", "Other", " \n"),
        manager = ui.new_combobox("AA", "Other", "  \aBBC0F3FF➤ \aE8E8E8FFTab Manager", {"\aBBC0F3FF❓ \aE8E8E8FFInfo", "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot", "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA", "\aBBC0F3FF✎ \aE8E8E8FFVisuals", "\aBBC0F3FF⚙️ \aE8E8E8FFConfig System"}),
        
        spacer1 = ui.new_label("AA", "Other", " \n"),
        label2 = ui.new_label("AA", "Other", "ㅤ\aBBC0F3FF- \aB3B7DDE2User: \aE8E8E8FF".."unknown"),
        label3 = ui.new_label("AA", "Other", "ㅤ\aBBC0F3FF- \aB3B7DDE2Build: \aE8E8E8FF"..string.lower(curr_build)),
        
        spacer2 = ui.new_label("AA", "Other", " \n"),


        label4 = ui.new_label("AA", "Other", "ㅤTime Elapsed:"),
        hours = ui.new_label("AA", "Other", "\aBBC0F3FF"..""),
        minutes = ui.new_label("AA", "Other", "\aBBC0F3FF"..""),
        seconds = ui.new_label("AA", "Other", "\aBBC0F3FF"..""),
        spacer3 = ui.new_label("AA", "Other", " \n"),
        fs = ui.new_checkbox("AA", "Other", "\aBBC0F3FFFreestanding", {"Default"}),
        fs_key = ui.new_hotkey("AA", "Other", "\nFreestanding Bind", true),
        sh_fs = ui.new_checkbox("AA", "Other", "\aBBC0F3FFEvade Freestand", {"Default"}),
        shfs_key = ui.new_hotkey("AA", "Other", "\ndwdwd", true),
        fs_sense = ui.new_slider("AA", "Other", "Freestanding Sensitivity", 0, 300, 120),
        osaa = ui.new_checkbox("AA", "Other", "\aBBC0F3FFOn shot anti-aim", {"Default"}),
        osaa_key = ui.new_hotkey("AA", "Other", "\nOSAA BIND", true),
    },

    info = {
        label1 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF➤ \aE8E8E8FFInformation"),
        label2 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        label3 = ui.new_label("AA", "Anti-aimbot angles", "Welcome \aBBC0F3FF".."[Player]".." \aE8E8E8FFto evade \aA8A8A8EE[\aFFFFFFFFgame\aB7D658FFsense\aA8A8A8EE] \n "),
        label4 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        label5 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF- \aE8E8E8FFLast Update: [\aBBC0F3FF09 / 01 / 2025\aE8E8E8FF]"),

        label10 = ui.new_label("AA", "Anti-aimbot angles", " \n "),  
        get_discord = ui.new_button("AA", "Anti-aimbot angles", "\aBBC0F3FFevade Discord", function() js_loadstring.OpenExternalBrowserURL("https://discord.gg/8g2WmefEAK") end),
    
        reset_login = ui.new_button("AA", "Anti-aimbot angles", "\aBBC0F3FFReset Login Memory", function ()

            writefile("login_details.txt", "NULL")
        
        end),
        spacer1 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        statistics = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFStatistics"),
        spacer2 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        times_loaded = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFTimes Loaded: ".."0"),
        hits = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFTimes Loaded: ".."0"),
        misses = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFTimes Loaded: ".."0"),
        accuracy = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFTimes Loaded: ".."0"),
        times_hit = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFTimes Hit"),
        times_missed = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFTimes Missed"),
        disablelogs = ui.new_checkbox("AA", "Anti-aimbot angles", "Disable Logs", true)

    },

    preset = {

        label1 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF➤ \aE8E8E8FFPresets"),
        spacer1 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        pre_type = ui.new_combobox("AA", "Anti-aimbot angles", "\n", {"Off", "Meta Jitter", "Delayed", "evade Special"}),
        spacer2 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        left = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Left", -100, 100, 0),
        right = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Right", -100, 100, 0),
        delay = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Delay", 1, 10, 1),
        force_def = ui.new_checkbox("AA", "Anti-aimbot angles", "\aE8E8E8FFForce\aBBC0F3FF Defensive \aE8E8E8FFon presets"),
    },
    
    aa_additions = {

        additions = ui.new_multiselect("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAnti\aE8E8E8FF-\aBBC0F3FFAim\aE8E8E8FF] ~\aE8E8E8FF Additions", {"Anti-Shank", "Hide Head", "Select Jitter", "Static Freestanding", "Display Anti-Bruteforce Target", "Beta Jitter"}),

        hidehead_drop = ui.new_multiselect("AA", "Anti-aimbot angles", "Hide head conditions", {"On Knife", "On Zeus"}),
        --[[
        leftlabel = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFLeft \aE8E8E8FF Manual\aBBC0F3FF ↰"),
        lefthotkey = ui.new_hotkey("AA", "Anti-aimbot angles", "\nBind", true),
        rightlabel = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFRight \aE8E8E8FF Manual\aBBC0F3FF ↱"),
        righthotkey = ui.new_hotkey("AA", "Anti-aimbot angles", "\nBind", true),
        forwardlabel = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFForward \aE8E8E8FF Manual\aBBC0F3FF ↑"),
        forwardhotkey = ui.new_hotkey("AA", "Anti-aimbot angles", "\nBind", true),
        resetlabel = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFReset \aE8E8E8FF Manual\aBBC0F3FF ↻"),
        resethotkey = ui.new_hotkey("AA", "Anti-aimbot angles", "\nBind", true),
        ]]
        --Manuals

    },

    def = {

        toggle = ui.new_checkbox("AA", "Anti-aimbot angles", "\aE8E8E8FFOverride \aBBC0F3FFDefensive \aE8E8E8FFAnti-aimbot"),
        spacer1 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        def_type = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Yaw Types", {"Desync", "Free-sync", "Experimental Yaw Flicks"}),


        -- Desync
        def_conds = ui.new_multiselect("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Conditions", {"Standing", "Air-Duck", "Air", "Running", "Duck", "Predict Visible", "Visible", "On Shot", "When Landing", "Unduck"}),
        ignore_fs = ui.new_checkbox("AA", "Anti-aimbot angles", "Ignore freestanding"),
        spacer2 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        override_def = ui.new_multiselect("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Overrides", {"Override Yaw", "Override Pitch"}),
        freesync_updt = ui.new_checkbox("AA", "Anti-aimbot angles", "Use Free-Sync Updating", false),
        label1 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF➤ \aE8E8E8FFYaw"),
        spacer3 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        yaw_type = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Yaw Types", {"Static", "Jitter", "Slow Jitter", "Spin", "Breaker"}),
        yaw = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Base Yaw", -180, 180, 0),
        radius = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Radius", -50, 50, 0),
        delay = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Speed / Delay", 1, 10, 1),
        spin_radius = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Radius", 0, 360, 0, true, "°"),
        spin_direction = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Direction", 1, 2, 1, true, "*", 1, {[1] = "Left", [2] = "Right"}),
        breaker_sequence = ui.new_combobox("AA", "Anti-aimbot angles", "Sequence Type", {"1 <-> 3", "1 >-< 3", "Unpure"}),
        breaker_statement1 = ui.new_slider("AA", "Anti-aimbot angles", "Statement #1", 2, 30, 2, true, "", 1, {[0] = "Invalid"}),
        breaker_statement2 = ui.new_slider("AA", "Anti-aimbot angles", "Statement #2 (Δ)", -30, 30, 0, true, "Δ", 1, {[0] = "Invalid"}),
        disrupt_spin = ui.new_checkbox("AA", "Anti-aimbot angles", "Disrupt Spin", false),
        def_hold_switch = ui.new_checkbox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Hold", false),
        def_hold = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Hold Amount", 0, 50, 2, true, "ms"),


        spacer3 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        label2 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF➤ \aE8E8E8FFPitch"),
        spacer4 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        flick_type = ui.new_combobox("AA", "Anti-aimbot angles", "Pitch Type", {"evade", "Custom"}),
        variation = ui.new_slider("AA", "Anti-aimbot angles", "Variation", 0, 50, 0, true, "°"),
        flick_rate = ui.new_slider("AA", "Anti-aimbot angles", "Flick Rate", 0, 50, 0),
        start_degree = ui.new_slider("AA", "Anti-aimbot angles", "Base Angle", 1, 6, 1, true, "*", 1, {[1] = "Down", [2] = "Half Down", [3] = "Zero", [4] = "Half Up", [5] = "Up", [6] = "Nod [Experiment]"}),
        trigger_pitch = ui.new_slider("AA", "Anti-aimbot angles", "Trigger Angle", 1, 5, 1, true, "*", 1, {[1] = "Down", [2] = "Half Down", [3] = "Zero", [4] = "Half Up", [5] = "Up"}),
        nodspeed = ui.new_slider("AA", "Anti-aimbot angles", "Nod Speed", 1, 100, 10, true),
        unpred_flick = ui.new_checkbox("AA", "Anti-aimbot angles", "Unpredictive Flicks"),



        spacer5 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        label3 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF➤ \aE8E8E8FFLag Switch"),
        spacer6 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        pause_time = ui.new_slider("AA", "Anti-aimbot angles", "Pause", 0, 100, 0, true, "t", 1, {[0] = "Disabled"}),



        -- Free-Sync
        freesync = {

            conditions = ui.new_multiselect("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Conditions", {"Jumping", "Lower Body Angles", "Smart"}),

            yaw_type = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Yaw Type", {"Inherit Jitter", "Adaptive", "Custom (Static)", "Custom (Jitter)"}),
            c_yaw_degree = ui.new_slider("AA", "Anti-aimbot angles", "\aBBC0F3FFCustom \aE8E8E8FF Yaw", 0, 360, 0, true, "°"),
            c_yaw_jitter_degree = ui.new_slider("AA", "Anti-aimbot angles", "\aBBC0F3FFCustom \aE8E8E8FF Jitter", 1, 3, 2,true, "*", 1, {[1] = "Low", [2] = "Mid", [3] = "High"}),
            
            pitch_type = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFDefensive\aE8E8E8FF] ~\aE8E8E8FF Pitch Type", {"Inherit", "Adaptive", "Custom"}),
            c_pitch_degree = ui.new_slider("AA", "Anti-aimbot angles", "\aBBC0F3FFCustom \aE8E8E8FF Pitch", 1, 5, 1, true, "*", 1, {[1] = "Down", [2] = "Half Down", [3] = "Zero", [4] = "Half Up", [5] = "Up"}),
        
        },

        -- Flicking Exp...
        flick = {
            yp_drop = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFFlick\aE8E8E8FF] ~\aE8E8E8FF Overrides", {"Yaw", "Yaw & Pitch"}),
            multiple_flicks = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFFlick\aE8E8E8FF] ~\aE8E8E8FF Ways", {"Single", "Double", "Random"}),
            firstflick = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFFlick\aE8E8E8FF] ~\aE8E8E8FF Nr \aBBC0F3FF1", {"Left", "Right", "Custom"}),
            first_custom_degree = ui.new_slider("AA", "Anti-aimbot angles", "Custom Nr \aBBC0F3FF1", -180, 180, 0, true, "°"),
            secondflick = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFFlick\aE8E8E8FF] ~\aE8E8E8FF Nr \aBBC0F3FF2", {"Left", "Right", "Custom"}),
            second_custom_degree = ui.new_slider("AA", "Anti-aimbot angles", "Custom Nr \aBBC0F3FF2", -180, 180, 0, true, "°"),
            quad_addon = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFFlick\aE8E8E8FF] ~\aE8E8E8FF Random", -90, 90, 0, true, "°", 1, {[-90] = "Full Left Rotate", [0] = "Off", [90] = "Full Right Rotate"}),
            regularity = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFFlick\aE8E8E8FF] ~\aE8E8E8FF Timer", {"Free-Sync", "Free-Sync+", "1/4", "1/6", "Defensive"}),
            freesync_res = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFFlick\aE8E8E8FF] ~\aE8E8E8FF Free-Sync Regularity", {"Spam", "High", "Mid", "Low", "Custom"}),
            custom_fcres = ui.new_slider("AA", "Anti-aimbot angles", "Custom Nr \aBBC0F3FF2", 2, 30, 10, true, ""),
            pitch = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFFlick\aE8E8E8FF] ~\aE8E8E8FF Pitch °", {"Up", "Semi-Up", "Zero"}),
        },
    },


    visuals = {
        toggle = ui.new_checkbox("AA", "Anti-aimbot angles", "Enable Visuals \aBBC0F3FF"),

        spacer1 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        label1 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF➤ \aE8E8E8FFCrosshair Indicators"),
        spacer2 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        colpick1 = ui.new_color_picker("AA", "Anti-aimbot angles", "LOL", 255, 255, 255, 255),
        crosshair = ui.new_combobox("AA", "Anti-aimbot angles", "\n", {"-", "Basic", "Modern", "New"}),

        spacer3 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        label2 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF➤ \aE8E8E8FFOther Indicators"),
        spacer4 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        colpick2 = ui.new_color_picker("AA", "Anti-aimbot angles", "LOL", 255, 255, 255, 255),
        other = ui.new_multiselect("AA", "Anti-aimbot angles", "\n", {"Bomb Timer", "Defensive", "Low Ammo", "Velocity", "Debug Panel"}),

        spacer5 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        label3 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF➤ \aE8E8E8FFLogs"),
        spacer6 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        colpick3 = ui.new_color_picker("AA", "Anti-aimbot angles", "LOL", 199, 193, 255, 255),
        logs = ui.new_multiselect("AA", "Anti-aimbot angles", "\n", {"Hit", "Miss", "Console Hit", "Console Miss", "Enemy Shots"}),
    }
}

local notify = (function()
    local b = vector;
    local c = function(d, b, c)
        return d + (b - d) * c
    end;
    local e = function()
        return b(client.screen_size())
    end;
    local f = function(d,...)
        local c = {...}
        local c = table.concat(c, "")
        return b(renderer.measure_text(d, c))
    end;
    
    local g = {
        notifications = {bottom = {}},
        max = {bottom = 6}
    }

    g.__index = g;
    g.new_bottom = function(h, i, j, ...)
        table.insert(
            g.notifications.bottom, 
            {started=false, 
            instance = setmetatable({active = false, timeout = 4, color = {["r"] = h, ["g"] = i, ["b"] = j, a = 0},x = e().x / 2, y = e().y, text = ...}, g)
            }
        )
    end;
        
        
    function g:handler()
        local d = 0;
        local b = 0;
        for d, b in pairs(g.notifications.bottom) do 
            if not b.instance.active and b.started then 
                table.remove(g.notifications.bottom,d)
            end
        end;
        
        for d = 1, #g.notifications.bottom do
            if g.notifications.bottom[d].instance.active then 
                b = b + 1 
            end
        end;
        
        for c, e in pairs(g.notifications.bottom) do 
            if c > g.max.bottom then 
                return 
            end;
            if e.instance.active then
                e.instance:render_bottom(d, b)
                d = d + 1 
            end;

            if not e.started then 
                e.instance:start()
                e.started = true 
            end 
        end 
    end;
    
    function g:start()
        self.active = true;
        self.delay = globals.realtime() + self.timeout
    end;
    
    function g:get_text()
        local d = ""
        local the_col = { ui.get(lua.visuals.colpick3) }
        for b, b in pairs(self.text) do 
            local c = f("",b[1])
            local c, e, f = 255, 255, 255;
            if b[2] then
                c, e, f = the_col[1] ,the_col[2] ,the_col[3] 
            end;

            d = d..("\a%02x%02x%02x%02x%s"):format(c,e,f,self.color.a,b[1])
        end;
        
        return d 
    end;
    
    local k = (function()
        local d = {}
        d.rec = function(d,b,c,e,f,g,k,l,m,l2)

            local the_col = { ui.get(lua.visuals.colpick3) }
            x, y, z = math.max(the_col[1],0), math.max(the_col[2],0), math.max(the_col[3],0)
            m = math.min(d / 2, b / 2, m)
            --renderer.rectangle(d, b + m, c, e - m * 2, f, g, k, l)
            --renderer.rectangle(d + m, b, c - m * 2, m, f, g, k, l)
            renderer.rectangle(d + m, b + e - m*2.7, c - m * 2, m * 2.75, f, g, k, l)
            --renderer.circle(d + m - 30, b + m, f, g, k, l, m, 180, .25)
            renderer.circle(d - m + c, b + m*1.4, f, g, k, l, m + 3, 0, 0.5)
            --renderer.circle(d - m + c + 30, b - m + e, f, g, k, l, m, 0, .25)
            renderer.circle(d + m, b + m*1.4, f, g, k, l, m + 3, 180, .5)


            -- Anims
            renderer.rectangle(d + m, b + e - m*2.7, math.min(c - m * 2, l), m-6, x, y, z, l)
            renderer.rectangle(c + m - 24 + (d + m), b + e - m*0.2, -math.min(c - m * 2, l), m-6, x, y, z, l)
            renderer.circle_outline(d + m, b + m*1.4, x, y, z, l, m + 3, 90, math.min(0.5, l*0.0023), m-6)
            renderer.circle_outline(d - m + c, b + m*1.4, x, y, z, l, m + 3, 270, math.min(0.5, l*0.0023), m-6)

        end;
            
        d.rec_outline = function(d, b, c, e, f, g, k, l, m, n)

            --[[

            d --> "X cordinates"
            b --> "Y cordinates"
            c --> "Width"



            ]]

            m = math.min(c / 2, e / 2, m)
            if m == 1 then
                renderer.rectangle(d, b, c, n, f, g, k, l)
                renderer.rectangle(d, b + e - n, c, n, f, g, k, l)
            else 
                renderer.rectangle(d + m, b, c - m * 2, n, f, g, k, l)
                renderer.rectangle(d + m, b + e - n, c - m * 2, n, f, g, k, l)
                --renderer.rectangle(d, b + m, n, e - m * 2, f, g, k, l)
                --renderer.rectangle(d + c - n, b + m, n, e - m * 2, f, g, k, l)
                --renderer.circle_outline(d + m, b + m, f, g, k, l, m, 180, .25, n)
                renderer.circle_outline(d + m,  b + m+3, f, g, k, l, m + 3, 90, 0.5, n)
                --renderer.circle_outline(d + c - m, b + m, f, g, k, l, m, -90, .25, n)
                renderer.circle_outline(d + c - m,  b + m+3, f, g, k, l, m + 3, 270, 0.5, n)
            end
        end;
        
        d.glow_module_notify = function(b, c, e, f, g, k, l, m, n, o, p, q, r, s, s)
            local t = 1;
            local u = 1;
            if s then 
                d.rec(b + 19, c + 1, e - 15, f - 1, l, m, n, o, k)
            end;
            
            for l = 0, g do
                local m = o / 2 * (l / g)^3;
                d.rec_outline(b + (l - g - u) * t + 19, c + (l - g - u) * t + 1, e - (l - g - u) * t * 2 - 15, f - (l - g - u) * t * 2 - 1, p , q, r, m / 1.5, k + t * (g - l + u), t)
            end 
        end;
        return d 
    end)
    
    
    ()function g:render_bottom(g,l)
        the_col = { ui.get(lua.visuals.colpick3) }
        local e = e()
        local m = 6;
        local n = "     "..self:get_text()
        local f = f("", n)
        local o = 8;
        local p = 5;
        local q = 0 + m + f.x;
        local q, r = q + p * 2, 12 + 10 + 1;
        local s, t = self.x - q / 2, math.ceil(self.y - 40 + .4)
        local u = globals.frametime() * 0.45
        local u2 = globals.frametime() * 0.45
        if globals.realtime() < self.delay then
            self.y = c(self.y, e.y - 45 - (l - g) * r * 1.4, u * 14)
            self.color.a = c(self.color.a, 255, u * 3)
            self.color.anim = c(self.color.a, 255, u * 1.5)
        else
            self.y = c(self.y, self.y - 10, u * 20)
            self.color.a = c(self.color.a, 0, u * 25)
            if self.color.a <= 1 then
                self.active=false 
            end 
        end;
        local h, i, j, l, l2 = self.color.r, self.color.g, self.color.b, self.color.a, self.color.anim


        k.glow_module_notify(s, t, q, r, 15, o, 25, 25, 25, l, the_col[1], the_col[2], the_col[3], l, true)
        --k.glow_module_notify(s - (s * 0.049), t, q - (q - 30), r, 15, o, 25, 25, 25, l, the_col[1], the_col[2], the_col[3], l, true)
        
        local k = p + 2;
        k = k + 0 + m;
       -- renderer.text(s - (s * 0.02), t + r / 2 - f.y / 2, the_col[1], the_col[2], the_col[3], l, "b", nil, "E")
        renderer.text(s + k, t + r / 2 - f.y / 2, 230, 230, 230, l, "", nil, n)
    end;
    
    client.set_event_callback("paint_ui",function()
        g:handler()
    end)
    return g
end)()
client.set_event_callback("bomb_planted",function()
    if ui.get(lua.info.disablelogs) then return end
    notify.new_bottom(255, 255, 255,{ {"⚠ Bomb has been planted!", true} })
end)


local login_menu = {

    no_access_msg1 = ui.new_label("AA", "Anti-aimbot angles", "You're not logged in!"),
    login_spacer = ui.new_label("AA", "Anti-aimbot angles", " "),
    user_label = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFUsername"),
    enter_user = ui.new_textbox("AA", "Anti-aimbot angles", "Username"),
    pass_label = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFPassword"),
    enter_pass = ui.new_textbox("AA", "Anti-aimbot angles", "Password"),


    -- Registration

    no_register_label = ui.new_label("AA", "Anti-aimbot angles", "You have not yet registered!"),
    register_spacer1 = ui.new_label("AA", "Anti-aimbot angles", " "),
    user_label2 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFUsername"),
    enter_user2 = ui.new_textbox("AA", "Anti-aimbot angles", "Username"),
    pass_label2 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFPassword"),
    enter_pass2 = ui.new_textbox("AA", "Anti-aimbot angles", "Password"),
    key_label2 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FFRegistration Key"),
    key_pass2 = ui.new_textbox("AA", "Anti-aimbot angles", "Registration Key"),
    



}


local import_key = ui.new_button("AA", "Anti-aimbot angles", "^ Import From Clipboard ^", function() 
    get_clipboard = clipboard.get()
    ui.set(login_menu.key_pass2, tostring(get_clipboard))
end)
local register_spacer2 = ui.new_label("AA", "Anti-aimbot angles", " ")



local double_check_register = ui.new_button("AA", "Anti-aimbot angles", "\aBBC0F3FFRegister", function ()

login_details.is_visible = true
end)

local confirm_register = ui.new_button("AA", "Anti-aimbot angles", "\aBBC0F3FFRegister (Confirm)", function ()
    get_base.encode = (base64.encode(hwid, "base64"))


    registration_string = (ui.get(login_menu.enter_user2).." "..ui.get(login_menu.enter_pass2))
    local tostring_login = (ui.get(login_menu.enter_user2)..ui.get(login_menu.enter_pass2))..ui.get(login_menu.key_pass2) 
    get_login = registration_string == "" and "NULL" or registration_string == " " and "NULL" or registration_string == "  " and "NULL" or registration_string
    if 
    --string.find(tostring_login, "") or 
    string.find(tostring_login, " ") or 
    string.find(tostring_login, "  ") or 
    string.find(tostring_login, "   ") or 
    string.find(tostring_login, "    ") or 
    string.find(tostring_login, "     ") or
    ui.get(login_menu.enter_user2) == "" or 
    ui.get(login_menu.enter_pass2) == "" or 
    ui.get(login_menu.key_pass2) == ""
    then
        get_login = "NULL"
    end
    if string.find(login_details.web_info, get_login) and string.find(login_details.web_info, ui.get(login_menu.key_pass2)) then
        login_details.is_registered = true
        client.color_log(235, 220, 255, "You've successfully registered an evade account!")
        writefile("hwid_management.txt", get_base.encode)
        notify.new_bottom(255, 255, 255,{ {"Your account has been \a989CBFFFsuccessfully\aFFFFFFFF created"} })

    else
        if registration_string == "" or registration_string == " " or registration_string == "  " then
            login_details.is_registered = false
            client.color_log(255, 180, 180, "Insufficient Credentials")
            notify.new_bottom(255, 255, 255, {{"\aF3696BFFFailed\aFFFFFFFF to create account"}})
        else
            login_details.is_registered = false
            client.color_log(255, 180, 180, "Incorrect Username Or Password!")
            notify.new_bottom(255, 255, 255, {{"\aF3696BFFFailed\aFFFFFFFF to create account"}})
        end
    end



end)




deny_register = ui.new_button("AA", "Anti-aimbot angles", "\aBBC0F3FFRegister (Cancel)", function ()

login_details.is_visible = false
end)

local login_button = ui.new_button("AA", "Anti-aimbot angles", "\aBBC0F3FFLoad", function ()
    get_log_vals = (ui.get(login_menu.enter_user).." "..ui.get(login_menu.enter_pass))
    get_login = get_log_vals == "" and "NULL" or get_log_vals == " " and "NULL" or get_log_vals == "  " and "NULL" or get_log_vals



    if string.find(login_details.web_info, get_login) then
        login_details.access = true
        client.color_log(235, 220, 255, "Successfully Loaded evade!")
        writefile("login_details.txt", get_login)
        writefile("evade_user.txt", ui.get(login_menu.enter_user))
        notify.new_bottom(255, 255, 255,{ {"Successfully logged in as: "}, {tostring(readfile("evade_user.txt")), true}})
    else
        if get_log_vals == "" or get_log_vals == " " or get_log_vals == "  " then
            login_details.access = false
            client.color_log(255, 180, 180, "Insufficient Credentials")
            notify.new_bottom(255, 255, 255, {{"Insufficient Credentials"}})
        else
            login_details.access = false
            client.color_log(255, 180, 180, "Incorrect Username Or Password!")
            notify.new_bottom(255, 255, 255, {{"Incorrect Username Or Password"}})
        end
    end
end)


local function getcombo(table, value)
	if table == nil then
		return false;
	end

    table = ui.get(table);
    for i=0, #table do
        if table[i] == value then
            return true;
        end
    end

    return false
end


local func = {

    _2hex = function(redArg, greenArg, blueArg, alphaArg)
        return string.format('%.2x%.2x%.2x%.2x', redArg, greenArg, blueArg, alphaArg)
    end,

    _isDT = function ()
        return anti_aim.get_double_tap()
    end,

    _dsy = function ()
        return anti_aim.get_desync(1)
    end,

    _delta = function ()
        local localplayer = entity.get_local_player()
        if not localplayer then
            return ""
        end
        return entity.get_prop(localplayer, "m_flPoseParameter", 11) * 120 - 60
    end,

    _ground = function ()
        local localplayer = entity.get_local_player();
        local flags = entity.get_prop(localplayer, 'm_fFlags');
    end,

    normalize = function(a)
        while a > 180 do
            a = a - 360
        end

        while a < -180 do
            a = a + 360
        end

        return a
    end,

    normalize_angle = function(angle)
        angle = angle % 360
        if angle > 180 then
            angle = angle - 360
        end
        return angle
    end,


    --[[
    delayed_jitter = function(self, cmd, data)
        local delay = {math.random(1, math.random(3, 4)), 2, 4, 5}
        local delayed = true

        if globals.chokedcommands() == 0 and aa_table.cycle == delay[lua.def.delay] then
            delayed = false
            self.side = self.side == 1 and 0 or 1
        end



        return (side == 2) and 0 or (side == 1 and 90 or -90)
    end,

    ]]

    

}





local flagtbl = {alpha = 0}
local closest_enemy = nil
local flag_is_switch_on = false
-- Update closest enemy once per frame
client.set_event_callback("paint", function()

    
    local local_player = entity.get_local_player()
    if not entity.is_alive(local_player) then
        closest_enemy = nil
        return
    end

    local enemies = entity.get_players(true)
    local closest_dist = math.huge
    closest_enemy = nil
    local local_origin = {entity.get_prop(local_player, "m_vecOrigin")}
    
    for _, enemy in pairs(enemies) do
        if entity.is_alive(enemy) then
            local enemy_origin = {entity.get_prop(enemy, "m_vecOrigin")}
            local dx = enemy_origin[1] - local_origin[1]
            local dy = enemy_origin[2] - local_origin[2]
            local dz = enemy_origin[3] - local_origin[3]
            local distance = math.sqrt(dx*dx + dy*dy + dz*dz)
            
            if distance < closest_dist then
                closest_dist = distance
                closest_enemy = enemy
            end
        end
    end
end)


client.register_esp_flag("BRUTE FOCUS \af57676FF⚠️", 200, 210, 130, function(e)
    flag_is_switch_on = false
    if getcombo(lua.aa_additions.additions, "Display Anti-Bruteforce Target") then
        return e == closest_enemy
    else
        return false
    end
end)




local function fired_at(target, shooter, shot)
    if entity.get_local_player() == nil then return false end
    local lp = entity.get_local_player()
    
    local shooter_cam = { get_camera_pos(shooter) }
    if shooter_cam[1] == nil then return false end
    
    -- Get multiple hitbox positions for more comprehensive checking
    local hitboxes = {}
    local hitbox_indices = {0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18}
    
    for _, index in ipairs(hitbox_indices) do
        local hitbox = { entity.hitbox_position(target, index) }
        if hitbox[1] ~= nil then
            table.insert(hitboxes, hitbox)
        end
    end
    
    -- Check if any hitbox is close to the shot trajectory
    for _, player_pos in ipairs(hitboxes) do
        local shooter_cam_to_head = { 
            player_pos[1] - shooter_cam[1], 
            player_pos[2] - shooter_cam[2], 
            player_pos[3] - shooter_cam[3] 
        }
        local shooter_cam_to_shot = { 
            shot[1] - shooter_cam[1], 
            shot[2] - shooter_cam[2], 
            shot[3] - shooter_cam[3]
        }
        
        local magic = ((shooter_cam_to_head[1]*shooter_cam_to_shot[1]) + 
                       (shooter_cam_to_head[2]*shooter_cam_to_shot[2]) + 
                       (shooter_cam_to_head[3]*shooter_cam_to_shot[3])) / 
                      (math.pow(shooter_cam_to_shot[1], 2) + 
                       math.pow(shooter_cam_to_shot[2], 2) + 
                       math.pow(shooter_cam_to_shot[3], 2))
        
        local closest = { 
            shooter_cam[1] + shooter_cam_to_shot[1]*magic, 
            shooter_cam[2] + shooter_cam_to_shot[2]*magic, 
            shooter_cam[3] + shooter_cam_to_shot[3]*magic
        }
        
        local length = math.abs(math.sqrt(
            math.pow((player_pos[1]-closest[1]), 2) + 
            math.pow((player_pos[2]-closest[2]), 2) + 
            math.pow((player_pos[3]-closest[3]), 2)
        ))
        
        local frac_shot = client.trace_line(shooter, shot[1], shot[2], shot[3], player_pos[1], player_pos[2], player_pos[3])
        local frac_final = client.trace_line(target, closest[1], closest[2], closest[3], player_pos[1], player_pos[2], player_pos[3])
        
        -- Kept the original 50 range and precision
        if length < 50 and (frac_shot > 0.95 or frac_final > 0.95) then
            return true
        end
    end
    
    return false
end

-- Shot tracking variables
local shot_tracking = {
    pending_shots = {},
    last_hit_time = 0,
    last_logged_miss = {
        enemy = nil,
        time = 0
    }
}

local function shot_log(e)
    -- Check if logs are disabled
    if ui.get(lua.info.disablelogs) then return end
    
    -- Ensure local player exists
    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then return end
    
    -- Get enemy shooter
    local enemy = client.userid_to_entindex(e.userid)
    if enemy == lp or not entity.is_enemy(enemy) then return end
    
    -- Check if shot was potentially aimed at local player
    if fired_at(lp, enemy, {e.x, e.y, e.z}) then
        -- Only proceed if logs are enabled for enemy shots
        if not getcombo(lua.visuals.logs, "Enemy Shots") then return end
        
        -- Clear any old pending shots
        for i = #shot_tracking.pending_shots, 1, -1 do
            if globals.curtime() - shot_tracking.pending_shots[i].time > 1 then
                table.remove(shot_tracking.pending_shots, i)
            end
        end
        
        -- Store pending shot for potential miss tracking
        local existing = false
        for _, shot in ipairs(shot_tracking.pending_shots) do
            if shot.enemy == enemy and 
               math.abs(shot.pos[1] - e.x) < 10 and 
               math.abs(shot.pos[2] - e.y) < 10 and 
               math.abs(shot.pos[3] - e.z) < 10 then
                existing = true
                break
            end
        end
        
        if not existing then
            table.insert(shot_tracking.pending_shots, {
                enemy = enemy,
                time = globals.curtime(),
                pos = {e.x, e.y, e.z},
                logged = false,
                hit = false
            })
        end
    end
end

-- Player hurt event to confirm hits
client.set_event_callback("player_hurt", function(e)
    local victim = client.userid_to_entindex(e.userid)
    local attacker = client.userid_to_entindex(e.attacker)
    
    -- Ensure the victim is the local player
    if victim ~= entity.get_local_player() then return end
    
    -- Find and log the hit
    for i = #shot_tracking.pending_shots, 1, -1 do
        local shot = shot_tracking.pending_shots[i]
        if shot.enemy == attacker and not shot.logged then
            -- Hit confirmed
            notify.new_bottom(255, 255, 255, {
                {"Player "}, 
                {entity.get_player_name(attacker), true}, 
                {" hit you"}
            })
            new_tbl.hit = new_tbl.hit + 1
            
            -- Mark as logged and hit to prevent miss logging
            shot.logged = true
            shot.hit = true
            shot_tracking.last_hit_time = globals.curtime()
            
            -- Remove this pending shot
            table.remove(shot_tracking.pending_shots, i)
            return 
        end
    end
end)

-- Miss tracking for shots that didn't hit
client.set_event_callback("bullet_impact", function(e)
    shot_log(e)
    
    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then return end
    
    client.delay_call(0.05, function()
        for i = #shot_tracking.pending_shots, 1, -1 do
            local shot = shot_tracking.pending_shots[i]
            
            -- Check if shot is not logged, not a hit, and not very recent
            if not shot.logged and not shot.hit and 
               globals.curtime() - shot.time > 0.05 and 
               globals.curtime() - shot_tracking.last_hit_time > 0.1 then
                
                -- Additional check to prevent double logging of miss
                local current_time = globals.curtime()
                if shot_tracking.last_logged_miss.enemy == shot.enemy and 
                   current_time - shot_tracking.last_logged_miss.time < 0.1 then
                    return
                end
                
                -- Missed shot
                notify.new_bottom(255, 255, 255, {
                    {"Player "}, 
                    {entity.get_player_name(shot.enemy), true}, 
                    {" missed you"}
                })
                new_tbl.miss = new_tbl.miss + 1
                
                -- Update last logged miss
                shot_tracking.last_logged_miss = {
                    enemy = shot.enemy,
                    time = current_time
                }
                
                -- Mark as logged to prevent duplicate logging
                shot.logged = true
                
                -- Remove this pending shot
                table.remove(shot_tracking.pending_shots, i)
            end
        end
    end)
end)

-- Round end reset
client.set_event_callback("round_end", function()
    if ui.get(lua.info.disablelogs) then return end
    notify.new_bottom(255, 255, 255,{ {"Anti-aim reset due to round end"} })

    -- Reset shot tracking variables
    shot_tracking = {
        pending_shots = {},
        last_hit_time = 0,
        last_logged_miss = {
            enemy = nil,
            time = 0
        }
    }
end)

local setup_timer = 0
local hitgroup_names = { "generic", "head", "chest", "stomach", "left arm", "right arm", "left leg", "right leg", "neck", "?", "gear" }

client.set_event_callback("aim_hit", function(e)
    play_data.hits = play_data.hits + 1
end)

client.set_event_callback("aim_miss", function(e)
    play_data.misses = play_data.misses + 1
end)

local elogs = {} do
    local shot_data = {}


    function elogs.aim_fire(e)
        


        shot_data[e.id] = {
            player = entity.get_player_name(e.target),
            wanted_hitgroup = hitgroup_names[e.hitgroup + 1] or "?",
            wanted_damage = e.damage,
            hit_chance = math.floor(e.hit_chance + 0.5),
            backtrack = globals.tickcount() - e.tick,
            tick = e.tick,
            taser = entity.get_classname(entity.get_player_weapon(entity.get_local_player())) == "CWeaponTaser"
        }
    end


    function elogs.aim_hit(e)
        col_logs = { ui.get(lua.visuals.colpick3) }

        col2hex = func._2hex(col_logs[1], col_logs[2], col_logs[3], col_logs[4])

        log_colors = {
            main = "\a"..col2hex,
            white = "\aFFFFFF"
        }

        
        local hitgroup = hitgroup_names[e.hitgroup + 1] or "?"
        local damage = e.damage
        local fired_shot = shot_data[e.id]
        if getcombo(lua.visuals.logs, "Console Hit") then
            print(string.format(
                "Hit %s\'s %s for %s (history: %s)",
                fired_shot.player, hitgroup, damage, fired_shot.backtrack

            ))
        end
        if getcombo(lua.visuals.logs, "Hit") then
            local hitstring = string.format(
                "Hit %s\'s %s for %s (history: %s)",
                fired_shot.player, hitgroup, damage, fired_shot.backtrack

            )
            if ui.get(lua.info.disablelogs) then return end
            notify.new_bottom(255, 255, 255, { { hitstring } })
        end

    end


    function elogs.aim_miss(e)

        local hitgroup = hitgroup_names[e.hitgroup + 1] or "?"
        local damage = e.damage
        local fired_shot = shot_data[e.id]
        if getcombo(lua.visuals.logs, "Console Miss") then
            print(string.format(
                "Missed %s\'s %s due to %s (history %s)",
                fired_shot.player, hitgroup, e.reason, fired_shot.backtrack

            ))
        end
        if getcombo(lua.visuals.logs, "Miss") then
            local hitstring = string.format(
                "Missed %s\'s %s due to %s (history %s)",
                fired_shot.player, hitgroup, e.reason, fired_shot.backtrack

            )
            if ui.get(lua.info.disablelogs) then return end
            notify.new_bottom(255, 255, 255, { { hitstring } })
        end

    end


end




ui.set_callback(lua.visuals.logs, function ()
    local update_callback = client.set_event_callback
    update_callback("aim_fire", elogs.aim_fire)
    update_callback("aim_hit",  elogs.aim_hit)
    update_callback("aim_miss",  elogs.aim_miss)

end)












local db_load = function()
    play_data.ticks_elapsed = play_data.ticks_elapsed + 1
    local get_username = readfile("evade_user.txt") ~= nil and readfile("evade_user.txt") or "unknown"
    ui.set(lua.home.label2, "ㅤ\aBBC0F3FF- \aB3B7DDE2User: \aE8E8E8FF"..get_username)
    ui.set(lua.info.label3, "Welcome \aBBC0F3FF"..get_username.." \aE8E8E8FFto evade \aA8A8A8EE[\aFFFFFFFFgame\aB7D658FFsense\aA8A8A8EE]")
   -- play_data.seconds = ((globals.curtime() - play_data.start_time))
    --play_data.minutes = ((globals.curtime() - play_data.start_time)) / 60
    --play_data.hours = ((globals.curtime() - play_data.start_time)) / 3600
    local minute_value = (globals.curtime() % 60) - play_data.start_time % 60
    local calculate_time = (math.floor(play_data.ticks_elapsed % 128) / 127)
    if calculate_time == 1 then
        play_data.seconds = play_data.seconds + 1
        play_data.minutes = play_data.minutes + 0.0166666667
        play_data.hours = play_data.hours + 0.000277777778
    end
    if play_data.seconds >= 60 then play_data.seconds = play_data.seconds - 60 end
    if play_data.minutes >= 60 then play_data.minutes = play_data.minutes - 60 end

    ui.set(lua.home.hours, "ㅤ\aBBC0F3FF- \aE8E8E8FF"..math.floor(play_data.hours).." \aBBC0F3FFHour \aE8E8E8FF(\aBBC0F3FFs\aE8E8E8FF)")
    ui.set(lua.home.minutes, "ㅤ\aBBC0F3FF- \aE8E8E8FF"..math.floor(play_data.minutes).." \aBBC0F3FFMinute \aE8E8E8FF(\aBBC0F3FFs\aE8E8E8FF)")
    ui.set(lua.home.seconds, "ㅤ\aBBC0F3FF- \aE8E8E8FF"..math.floor(play_data.seconds).." \aBBC0F3FFSecond \aE8E8E8FF(\aBBC0F3FFs\aE8E8E8FF)")



    local total_shots = (play_data.misses + play_data.hits)

    play_data.hm_ratio = math.floor((play_data.hits / total_shots) * 100)

    if total_shots == 0 then
        play_data.hm_ratio = 100
    end

    local get_loadtimes = database.read("evade_stats") ~= nil and database.read("evade_stats") or "unknown"
    ui.set(lua.info.times_loaded, "\aFFFFFFFF~ \aBBC0F3FFTimes Loaded: \aE8E8E8FF "..loadCount)
    ui.set(lua.info.hits, "\aFFFFFFFF~ \aBBC0F3FFHits: \aE8E8E8FF "..play_data.hits)
    ui.set(lua.info.misses, "\aFFFFFFFF~ \aBBC0F3FFMisses: \aE8E8E8FF "..play_data.misses)
    ui.set(lua.info.accuracy, "\aFFFFFFFF~ \aBBC0F3FFShot Accuracy: \aE8E8E8FF "..play_data.hm_ratio.."%")

    ui.set(lua.info.times_missed, "\aFFFFFFFF~ \aBBC0F3FFEnemy Misses: \aE8E8E8FF "..new_tbl.miss)
    ui.set(lua.info.times_hit, "\aFFFFFFFF~ \aBBC0F3FFEnemy Hits: \aE8E8E8FF "..new_tbl.hit)
end

local on_load = function()


    if not readfile("login_details.txt") then return end
    if string.find(login_details.web_info, readfile("login_details.txt")) then
        login_details.access = true
    end

    if login_details.is_registered == false then
        login_details.access = false
    end
end






local get_username = readfile("evade_user.txt") ~= nil and readfile("evade_user.txt") or "unknown"

if readfile("evade_user.txt") ~= nil then
    notify.new_bottom(255, 255, 255, {{"User "}, {get_username, true}, {" has successfully loaded ["}, {"evade", true}, {"]"}})
else
    if readfile("hwid_management.txt") == nil then
        notify.new_bottom(255, 255, 255, { { "You have \aF3696BFFnot\aFFFFFFFF registered yet" }})
    else
        notify.new_bottom(255, 255, 255, { { "You are \aF3696BFFnot\aFFFFFFFF yet logged in" }})
    end
    
end

local aa = {}
local anti_bruteforce = {}



local cond_select = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAnti\aE8E8E8FF-\aBBC0F3FFAim\aE8E8E8FF] ~\aE8E8E8FF Conditions", {states[1], states[2], states[3], states[4], states[5], states[6], states[7], states[8]})
for i, v in next, states do
    aa[v] = {}
    antiaim[i] = {

        ovr_state = ui.new_checkbox("AA", "Anti-aimbot angles", "Override \aBBC0F3FF"..states[i].."\aE8E8E8FF Anti-Aim"),
        force_def = ui.new_checkbox("AA", "Anti-aimbot angles", "Force \aBBC0F3FFDefensive \aE8E8E8FFAnti-Aim"),
        spacer1 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        label1 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF➤ \aE8E8E8FFAdjust Body Yaw"),
        spacer2 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        body_movement = ui.new_combobox("AA", "Anti-aimbot angles", "\n", {"Default", "Jitter", "Slow", "AI"}),
        b_yaw = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Base Yaw", -100, 100, 0),
        b_left = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Left", -100, 100, 0),
        b_right = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Right", -100, 100, 0),
        slow_type = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Switch Type", {"Single", "Double", "Unpredictive"}),
        ghost = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Jitter Regularity", {"Normal", "Ghost"}),
        switch_timer = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Timer", 1, 15, 0),
        b_delay = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Delay", 1, 15, 1),
        b_delay1 = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Delay 1", 1, 15, 1),
        b_delay2 = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Delay 2", 1, 15, 1),
        variation = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Variation", 0, 5, 1),

        irregulization = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Shifting Yaw", {"Off", "Step", "Randomize"}),
        left_irreg_amount = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Left Shift Amount", 1, 50, 1, true, "%", 1),
        right_irreg_amount = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Right Shift Amount", 1, 50, 1, true, "%", 1),
        global_irreg_amount = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Right Shift Amount", 1, 50, 1, true, "%", 1),

        spacer3 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        label2 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF➤ \aE8E8E8FFYaw Jitter"),
        spacer4 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        jitter_type = ui.new_combobox("AA", "Anti-aimbot angles", "\n", {"Off", "Offset", "Center", "Stomp"}),
        j_rad = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Radius", -50, 50, 0),

        spacer5 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        label3 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF➤ \aE8E8E8FFDesync"),
        spacer6 = ui.new_label("AA", "Anti-aimbot angles", " \n "),
        desync_type = ui.new_combobox("AA", "Anti-aimbot angles", "\n", {"Gamesense", "Reversed"}),
        fake = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAA\aE8E8E8FF] ~\aE8E8E8FF Fake", 0, 58, 0, true, "°", 1)
    }
end

local bruteforce_conditions = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAnti\aE8E8E8FF-\aBBC0F3FFBrute\aE8E8E8FF] ~\aE8E8E8FF Conditions",{states[1], states[2], states[3], states[4], states[5], states[6], states[7], states[8]})
for i, v in next, states do
    anti_bruteforce[i] = {
        ovr_state = ui.new_checkbox("AA", "Anti-aimbot angles", "Override \aBBC0F3FF"..states[i]..""),
        type = ui.new_combobox("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAnti\aE8E8E8FF-\aBBC0F3FFBrute\aE8E8E8FF] ~\aE8E8E8FF Type", {"None", "Preset", "Custom"}),
        overrides = ui.new_multiselect("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAnti\aE8E8E8FF-\aBBC0F3FFBrute\aE8E8E8FF] ~\aE8E8E8FF Overrides", {"Yaw", "Yaw Delay"}),
        left_yaw = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAnti\aE8E8E8FF-\aBBC0F3FFBrute\aE8E8E8FF] ~\aE8E8E8FF Left Yaw Adder", -20, 20, 0),
        right_yaw = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAnti\aE8E8E8FF-\aBBC0F3FFBrute\aE8E8E8FF] ~\aE8E8E8FF Left Yaw Adder", -20, 20, 0),
        delay = ui.new_slider("AA", "Anti-aimbot angles", "\aE8E8E8FF[\aBBC0F3FFAnti\aE8E8E8FF-\aBBC0F3FFBrute\aE8E8E8FF] ~\aE8E8E8FF Delay Adder", -3, 3, 0)
    }
end

local config_ui = {
    label1 = ui.new_label("AA", "Anti-aimbot angles", "\aBBC0F3FF➤ \aE8E8E8FFConfig System"),
    list = ui.new_listbox("AA", "Anti-aimbot angles", "Configs", {}),
    name = ui.new_textbox("AA", "Anti-aimbot angles", "Config name"),
    create = ui.new_button("AA", "Anti-aimbot angles", "Create", function() end),
    save = ui.new_button("AA", "Anti-aimbot angles", "Save", function() end),
    load = ui.new_button("AA", "Anti-aimbot angles", "Load", function() end),
    delete = ui.new_button("AA", "Anti-aimbot angles", "Delete", function() end),
}

local function save_config_list()
    writefile("evade_cfglist.txt", json.stringify(configs.list))
end

local function load_config_list()
    local data = readfile("evade_cfglist.txt")
    if data ~= nil and data ~= "" then
        local success, result = pcall(json.parse, data)
        if success and result then
            configs.list = result
        else
            configs.list = {}
        end
    else
        configs.list = {}
        writefile("evade_cfglist.txt", "[]")
    end
    return configs.list
end
local function create_config()
    local name = ui.get(config_ui.name)
    if name == "" then
        print("Please enter a config name")
        return
    end

    -- Create comprehensive config data
    local config = {
        menu = {},
        lua = {
            preset = {},
            aa_additions = {},
            def = {},
            home = {},
            visuals = {}
        },
        antiaim = {},
        colors = {}
    }

    -- Save lua elements
    for _, section in ipairs({"preset", "aa_additions", "def", "home", "visuals"}) do
        for key, value in pairs(lua[section]) do
            if type(value) ~= "userdata" and type(value) ~= "function" then
                if section == "visuals" and (key == "colpick1" or key == "colpick2" or key == "colpick3") then
                    local r, g, b, a = ui.get(value)
                    config.lua[section][key] = {r = r, g = g, b = b, a = a}
                else
                    local success, result = pcall(ui.get, value)
                    if success then
                        config.lua[section][key] = result
                    end
                end
            end
        end
    end

    -- Save antiaim states
    for i = 1, #states do
        config.antiaim[i] = {}
        for key, value in pairs(antiaim[i]) do
            if type(value) ~= "userdata" and type(value) ~= "function" then
                local success, result = pcall(ui.get, value)
                if success then
                    config.antiaim[i][key] = result
                end
            end
        end
    end

    -- Save menu elements
    for key, value in pairs(menu) do
        if type(value) == "table" then
            config.menu[key] = {}
            for i, element in ipairs(value) do
                if type(element) ~= "userdata" and type(element) ~= "function" then
                    local success, result = pcall(ui.get, element)
                    if success then
                        config.menu[key][i] = result
                    end
                end
            end
        else
            if type(value) ~= "userdata" and type(value) ~= "function" then
                local success, result = pcall(ui.get, value)
                if success then
                    config.menu[key] = result
                end
            end
        end
    end

    -- Save config to file
    writefile("evadecfg_" .. name .. ".txt", json.stringify(config))
    
    -- Update list
    table.insert(configs.list, name)
    save_config_list()
    ui.update(config_ui.list, configs.list)
    notify.new_bottom(255, 255, 255, {{"Created Config: ", true}, {name}})
end

local function save_config()
    local selected = ui.get(config_ui.list)
    if selected == nil then return end
    
    local name = configs.list[selected + 1]
    if name == nil then return end

    -- Create config data
    local config = {
        menu = {},
        lua = {
            preset = {},
            aa_additions = {},
            def = {},
            home = {},
            visuals = {}
        },
        antiaim = {},
        colors = {}
    }

    -- Save lua elements
    for _, section in ipairs({"preset", "aa_additions", "def", "home", "visuals"}) do
        for key, value in pairs(lua[section]) do
            if type(value) ~= "userdata" and type(value) ~= "function" then
                if section == "visuals" and (key == "colpick1" or key == "colpick2" or key == "colpick3") then
                    local r, g, b, a = ui.get(value)
                    config.lua[section][key] = {r = r, g = g, b = b, a = a}
                else
                    local success, result = pcall(ui.get, value)
                    if success then
                        config.lua[section][key] = result
                    end
                end
            end
        end
    end

    -- Save antiaim states
    for i = 1, #states do
        config.antiaim[i] = {}
        for key, value in pairs(antiaim[i]) do
            if type(value) ~= "userdata" and type(value) ~= "function" then
                local success, result = pcall(ui.get, value)
                if success then
                    config.antiaim[i][key] = result
                end
            end
        end
    end

    -- Save menu elements
    for key, value in pairs(menu) do
        if type(value) == "table" then
            config.menu[key] = {}
            for i, element in ipairs(value) do
                if type(element) ~= "userdata" and type(element) ~= "function" then
                    local success, result = pcall(ui.get, element)
                    if success then
                        config.menu[key][i] = result
                    end
                end
            end
        else
            if type(value) ~= "userdata" and type(value) ~= "function" then
                local success, result = pcall(ui.get, value)
                if success then
                    config.menu[key] = result
                end
            end
        end
    end

    writefile("evadecfg_" .. name .. ".txt", json.stringify(config))
    notify.new_bottom(255, 255, 255, {{"Saved Config: ", true}, {name}})
end

local function load_config()
    local selected = ui.get(config_ui.list)
    if selected == nil then return end
    
    local name = configs.list[selected + 1]
    if name == nil then return end

    local data = readfile("evadecfg_" .. name .. ".txt")
    if not data then return end

    local success, config = pcall(json.parse, data)
    if not success or not config then
        print("Failed to load config")
        return
    end

    -- Load lua elements
    for _, section in ipairs({"preset", "aa_additions", "def", "home", "visuals"}) do
        for key, value in pairs(config.lua[section] or {}) do
            if lua[section][key] then
                if section == "visuals" and (key == "colpick1" or key == "colpick2" or key == "colpick3") then
                    if type(value) == "table" and value.r and value.g and value.b and value.a then
                        pcall(ui.set, lua[section][key], value.r, value.g, value.b, value.a)
                    end
                else
                    pcall(ui.set, lua[section][key], value)
                end
            end
        end
    end

    -- Load antiaim states
    for i = 1, #states do
        if config.antiaim[i] then
            for key, value in pairs(config.antiaim[i]) do
                if antiaim[i][key] and type(value) ~= "userdata" and type(value) ~= "function" then
                    pcall(ui.set, antiaim[i][key], value)
                end
            end
        end
    end

    -- Load menu elements
    for key, value in pairs(config.menu or {}) do
        if menu[key] then
            if type(menu[key]) == "table" then
                for i, setting in ipairs(value) do
                    if menu[key][i] and type(setting) ~= "userdata" and type(setting) ~= "function" then
                        pcall(ui.set, menu[key][i], setting)
                    end
                end
            else
                if type(value) ~= "userdata" and type(value) ~= "function" then
                    pcall(ui.set, menu[key], value)
                end
            end
        end
    end

    notify.new_bottom(255, 255, 255, {{"Loaded Config: ", true}, {name}})
end
local function delete_config()
    local selected = ui.get(config_ui.list)
    if selected == nil then return end
    
    local name = configs.list[selected + 1]
    if name == nil then return end

    -- Delete config file
    writefile("evadecfg_" .. name .. ".txt", "")
    
    -- Update list
    table.remove(configs.list, selected + 1)
    save_config_list()
    ui.update(config_ui.list, configs.list)
    
    notify.new_bottom(255, 255, 255, {{"Deleted Config: ", true}, {name}})
end

-- Set up callbacks
ui.set_callback(config_ui.create, create_config)
ui.set_callback(config_ui.save, save_config)
ui.set_callback(config_ui.load, load_config)
ui.set_callback(config_ui.delete, delete_config)

load_config_list()
ui.update(config_ui.list, configs.list)

local config_sys = {
    
    

    export_cfg = ui.new_button("AA", "Anti-aimbot angles", "  \aBBC0F3FFExport to clipboard  ", function()
        local config = {
            menu = {},
            lua = {
                preset = {},
                aa_additions = {},
                def = {},
                home = {},
                visuals = {}
            },
            antiaim = {},
            colors = {}
        }

        -- Export menu elements
        for key, value in pairs(menu) do
            if type(value) == "table" then
                config.menu[key] = {}
                for i, element in ipairs(value) do
                    if type(element) ~= "userdata" and type(element) ~= "function" then
                        local success, result = pcall(ui.get, element)
                        if success then
                            config.menu[key][i] = result
                        end
                    end
                end
            else
                if type(value) ~= "userdata" and type(value) ~= "function" then
                    local success, result = pcall(ui.get, value)
                    if success then
                        config.menu[key] = result
                    end
                end
            end
        end

        -- Export lua elements
        for _, section in ipairs({"preset", "aa_additions", "def", "home", "visuals"}) do
            for key, value in pairs(lua[section]) do
                if type(value) ~= "userdata" and type(value) ~= "function" then
                    -- Special handling for visual section color pickers
                    if section == "visuals" and (key == "colpick1" or key == "colpick2" or key == "colpick3") then
                        local r, g, b, a = ui.get(value)
                        config.lua[section][key] = {r = r, g = g, b = b, a = a}
                    else
                        local success, result = pcall(ui.get, value)
                        if success then
                            config.lua[section][key] = result
                        end
                    end
                end
            end
        end

        -- Export antiaim states
        for i = 1, #states do
            config.antiaim[i] = {}
            for key, value in pairs(antiaim[i]) do
                if type(value) ~= "userdata" and type(value) ~= "function" then
                    -- Check if this is a color picker
                    local elementType = tostring(value):lower()
                    if elementType:find("color_picker") then
                        local success, r, g, b, a = pcall(ui.get, value)
                        if success then
                            config.colors["antiaim_" .. i .. "_" .. key] = {r = r, g = g, b = b, a = a}
                        end
                    else
                        local success, result = pcall(ui.get, value)
                        if success then
                            config.antiaim[i][key] = result
                        end
                    end
                end
            end
        end

        -- Encode and set clipboard with error handling
        local success, encoded = pcall(function()
            return "evade_" .. base64.encode(json.stringify(config))
        end)

        if success then
            clipboard.set(encoded)
            notify.new_bottom(255, 255, 255, {{"Exported", true}, {" config"}})
        else
            notify.new_bottom(255, 255, 255, {{"Failed to export config"}})
        end
    end),

    import_cfg = ui.new_button("AA", "Anti-aimbot angles", "  \aBBC0F3FFImport from clipboard", function()
        local success, result = pcall(function()
            local encoded_config = clipboard.get():gsub("evade_", "")
            return json.parse(base64.decode(encoded_config))
        end)

        if not success then
            notify.new_bottom(255, 255, 255, {{"Failed to decode config"}})
            return
        end

        local config = result

        -- Import menu elements
        for key, value in pairs(config.menu or {}) do
            if menu[key] then
                if type(menu[key]) == "table" then
                    for i, setting in ipairs(value) do
                        if menu[key][i] and type(setting) ~= "userdata" and type(setting) ~= "function" then
                            pcall(ui.set, menu[key][i], setting)
                        end
                    end
                else
                    if type(value) ~= "userdata" and type(value) ~= "function" then
                        pcall(ui.set, menu[key], value)
                    end
                end
            end
        end

        -- Import lua elements
        for _, section in ipairs({"preset", "aa_additions", "def", "home", "visuals"}) do
            for key, value in pairs(config.lua[section] or {}) do
                if lua[section][key] then
                    -- Special handling for visual section color pickers
                    if section == "visuals" and (key == "colpick1" or key == "colpick2" or key == "colpick3") then
                        if type(value) == "table" and value.r and value.g and value.b and value.a then
                            pcall(ui.set, lua[section][key], value.r, value.g, value.b, value.a)
                        end
                    else
                        if type(value) ~= "userdata" and type(value) ~= "function" then
                            pcall(ui.set, lua[section][key], value)
                        end
                    end
                end
            end
        end

        -- Import color settings
        for id, color in pairs(config.colors or {}) do
            local section, key = id:match("(.+)_(.+)")
            if section and key then
                if section:find("antiaim_") then
                    local index = tonumber(section:match("antiaim_(%d+)"))
                    local actualKey = key
                    if index and antiaim[index] and antiaim[index][actualKey] then
                        pcall(ui.set, antiaim[index][actualKey], color.r, color.g, color.b, color.a)
                    end
                else
                    if lua[section] and lua[section][key] then
                        pcall(ui.set, lua[section][key], color.r, color.g, color.b, color.a)
                    end
                end
            end
        end

        -- Import antiaim states
        for i = 1, #states do
            if config.antiaim[i] then
                for key, value in pairs(config.antiaim[i]) do
                    if antiaim[i][key] and type(value) ~= "userdata" and type(value) ~= "function" then
                        pcall(ui.set, antiaim[i][key], value)
                    end
                end
            end
        end

        notify.new_bottom(255, 255, 255, {{"Imported", true}, {" config"}})
    end)
}










local function fix_antiaim_visibility()

    local has_access = login_details.access == true
    login_details.has_access = has_access
    local when_builder = ui.get(aa_type) == "Builder" and ui.get(aa_tabs) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot"
    local when_preset = ui.get(aa_type) == "Presets" and ui.get(aa_tabs) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot"
    local sync_defensive_desync = ui.get(lua.def.def_type) == "Desync"

    ui.set_visible(config_sys.export_cfg, ui.get(lua.home.manager) == "\aBBC0F3FF⚙️ \aE8E8E8FFConfig System")
    ui.set_visible(config_sys.import_cfg, ui.get(lua.home.manager) == "\aBBC0F3FF⚙️ \aE8E8E8FFConfig System")
    --ui.set_visible(config_sys.default_cfg, ui.get(lua.home.manager) == "\aBBC0F3FF⚙️ \aE8E8E8FFConfig System")
    ui.set_visible(config_ui.label1, ui.get(lua.home.manager) == "\aBBC0F3FF⚙️ \aE8E8E8FFConfig System")


    ui.set_visible(config_ui.list, ui.get(lua.home.manager) == "\aBBC0F3FF⚙️ \aE8E8E8FFConfig System" and has_access)
    ui.set_visible(config_ui.name, ui.get(lua.home.manager) == "\aBBC0F3FF⚙️ \aE8E8E8FFConfig System" and has_access)
    ui.set_visible(config_ui.create, ui.get(lua.home.manager) == "\aBBC0F3FF⚙️ \aE8E8E8FFConfig System" and has_access)
    ui.set_visible(config_ui.save, ui.get(lua.home.manager) == "\aBBC0F3FF⚙️ \aE8E8E8FFConfig System" and has_access)
    ui.set_visible(config_ui.load, ui.get(lua.home.manager) == "\aBBC0F3FF⚙️ \aE8E8E8FFConfig System" and has_access)
    ui.set_visible(config_ui.delete, ui.get(lua.home.manager) == "\aBBC0F3FF⚙️ \aE8E8E8FFConfig System" and has_access)
    

    ui.set_visible(lua.preset.label1, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_preset and has_access)
    ui.set_visible(lua.preset.spacer1, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_preset and has_access)
    ui.set_visible(lua.preset.pre_type, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_preset and has_access)
    ui.set_visible(lua.preset.spacer2, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_preset and has_access)
    ui.set_visible(lua.preset.left, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_preset and has_access and ui.get(lua.preset.pre_type) == "Delayed")
    ui.set_visible(lua.preset.right, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_preset and has_access and ui.get(lua.preset.pre_type) == "Delayed")
    ui.set_visible(lua.preset.delay, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_preset and has_access and ui.get(lua.preset.pre_type) == "Delayed")
    ui.set_visible(lua.preset.force_def, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_preset and has_access)


    ui.set_visible(aa_tabs, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and has_access)
    ui.set_visible(firstlabel, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and has_access)
    ui.set_visible(aa_type, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and ui.get(aa_tabs) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and has_access)
    ui.set_visible(cond_select, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and ui.get(aa_type) == "Builder" and has_access)
    for i = 1, #states do
        local show_rad = ui.get(antiaim[i].body_movement) ~= "Default"
        local is_timer_true = ui.get(antiaim[i].slow_type) == "Double" or ui.get(antiaim[i].slow_type) == "Unpredictive"
        local show_delay = ui.get(antiaim[i].body_movement) == "Slow"
        local is_second_check = ui.get(lua.def.flick.multiple_flicks) == "Double"
        local not_ai = ui.get(antiaim[i].body_movement) ~= "AI"
        ui.set_visible(lua.aa_additions.additions, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and ui.get(aa_tabs) == "\aBBC0F3FF∑ \aE8E8E8FFExtra" and has_access)
        ui.set_visible(lua.aa_additions.hidehead_drop, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and ui.get(aa_tabs) == "\aBBC0F3FF∑ \aE8E8E8FFExtra" and has_access and getcombo(lua.aa_additions.additions, "Hide Head"))

        ui.set_visible(cond_select, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].ovr_state, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].spacer1, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].label1, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].body_movement, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].slow_type, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access and  show_delay)
        ui.set_visible(antiaim[i].ghost, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access and not show_delay and show_rad and not_ai)
        ui.set_visible(antiaim[i].irregulization, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access and not_ai)
        ui.set_visible(antiaim[i].left_irreg_amount, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access and show_rad and not_ai)
        ui.set_visible(antiaim[i].right_irreg_amount, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access and show_rad and not_ai)
        ui.set_visible(antiaim[i].global_irreg_amount, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access and not show_rad and not_ai)
        ui.set_visible(antiaim[i].switch_timer, is_timer_true and ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access and not_ai)
        ui.set_visible(antiaim[i].spacer2, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access and not_ai)
        ui.set_visible(antiaim[i].b_yaw, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access and not_ai)
        ui.set_visible(antiaim[i].b_left, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and show_rad and has_access and not_ai)
        ui.set_visible(antiaim[i].b_right, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and show_rad and has_access and not_ai)
        ui.set_visible(antiaim[i].b_delay, ui.get(antiaim[i].slow_type) == "Single" and ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and show_delay and has_access and not_ai)
        ui.set_visible(antiaim[i].b_delay1, ui.get(antiaim[i].slow_type) == "Double" and ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and show_delay and has_access and not_ai)
        ui.set_visible(antiaim[i].b_delay2, ui.get(antiaim[i].slow_type) == "Double" and ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and show_delay and has_access and not_ai)
        ui.set_visible(antiaim[i].variation, ui.get(antiaim[i].slow_type) == "Double" and ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and show_delay and has_access and not_ai)


        ui.set_visible(antiaim[i].spacer3, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].label2, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].spacer4, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].jitter_type, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].j_rad, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and ui.get(antiaim[i].jitter_type) ~= "Off" and has_access)

        ui.set_visible(antiaim[i].force_def, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].desync_type, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].fake, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].spacer6, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].label3, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)
        ui.set_visible(antiaim[i].spacer5, ui.get(cond_select) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and when_builder and has_access)

    end

    ui.set_visible(bruteforce_conditions, ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and ui.get(aa_tabs) == "\aFFDF62FF⚠ \aE8E8E8FFAnti-Bruteforce" and has_access)

    for i = 1, #states do

        local brute_ovr_state = true
        local iscustom = ui.get(anti_bruteforce[i].type) == "Custom"
        local brute_ovr_yaw = getcombo(anti_bruteforce[i].overrides, "Yaw")
        local brute_ovr_delay = getcombo(anti_bruteforce[i].overrides, "Yaw Delay")
        ui.set_visible(anti_bruteforce[i].ovr_state, ui.get(bruteforce_conditions) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and ui.get(aa_tabs) == "\aFFDF62FF⚠ \aE8E8E8FFAnti-Bruteforce" and has_access)
        ui.set_visible(anti_bruteforce[i].type, brute_ovr_state and ui.get(bruteforce_conditions) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and ui.get(aa_tabs) == "\aFFDF62FF⚠ \aE8E8E8FFAnti-Bruteforce" and has_access)
        ui.set_visible(anti_bruteforce[i].overrides, iscustom and brute_ovr_state and ui.get(bruteforce_conditions) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and ui.get(aa_tabs) == "\aFFDF62FF⚠ \aE8E8E8FFAnti-Bruteforce" and has_access)
        ui.set_visible(anti_bruteforce[i].left_yaw, brute_ovr_yaw and iscustom and brute_ovr_state and ui.get(bruteforce_conditions) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and ui.get(aa_tabs) == "\aFFDF62FF⚠ \aE8E8E8FFAnti-Bruteforce" and has_access)
        ui.set_visible(anti_bruteforce[i].right_yaw, brute_ovr_yaw and iscustom and brute_ovr_state and ui.get(bruteforce_conditions) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and ui.get(aa_tabs) == "\aFFDF62FF⚠ \aE8E8E8FFAnti-Bruteforce" and has_access)
        ui.set_visible(anti_bruteforce[i].delay, brute_ovr_delay and iscustom and brute_ovr_state and ui.get(bruteforce_conditions) == states[i] and ui.get(lua.home.manager) == "\aF48080FF⛔ \aE8E8E8FFAnti-Aimbot" and ui.get(aa_tabs) == "\aFFDF62FF⚠ \aE8E8E8FFAnti-Bruteforce" and has_access)
        ui.set_visible(anti_bruteforce[1].ovr_state, false)

    end

        --DEFENSIVE MENU
        ui.set_visible(lua.def.toggle, ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and has_access)
        ui.set_visible(lua.def.spacer1, ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and has_access)
        ui.set_visible(lua.def.def_type, ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and has_access and ui.get(lua.def.toggle))
        ui.set_visible(lua.def.def_conds, ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access and sync_defensive_desync)
        ui.set_visible(lua.def.ignore_fs, ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access and sync_defensive_desync)
        ui.set_visible(lua.def.override_def, ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access and sync_defensive_desync)
        ui.set_visible(lua.def.freesync_updt, ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access and sync_defensive_desync)
        ui.set_visible(lua.def.spacer2, ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access and sync_defensive_desync)
        ui.set_visible(lua.def.label1, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.spacer3, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.yaw_type, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.def_hold_switch, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.def_hold, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.yaw, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and ui.get(lua.def.yaw_type) ~= "Breaker" and has_access)
        ui.set_visible(lua.def.radius, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and ui.get(lua.def.yaw_type) ~= "Spin" and ui.get(lua.def.yaw_type) ~= "Static" and ui.get(lua.def.yaw_type) ~= "Breaker" and has_access)
        ui.set_visible(lua.def.delay, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and ui.get(lua.def.yaw_type) ~= "Jitter" and ui.get(lua.def.yaw_type) ~= "Static" and ui.get(lua.def.yaw_type) ~= "Breaker" and has_access)
        ui.set_visible(lua.def.spin_radius, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and ui.get(lua.def.yaw_type) == "Spin" and has_access)
        ui.set_visible(lua.def.spin_direction, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and ui.get(lua.def.yaw_type) == "Spin" and has_access)
        ui.set_visible(lua.def.disrupt_spin, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and ui.get(lua.def.yaw_type) == "Spin" and has_access)

        ui.set_visible(lua.def.breaker_sequence, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and ui.get(lua.def.yaw_type) == "Breaker" and has_access)
        ui.set_visible(lua.def.breaker_statement1, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and ui.get(lua.def.yaw_type) == "Breaker" and has_access)
        ui.set_visible(lua.def.breaker_statement2, sync_defensive_desync and getcombo(lua.def.override_def, "Override Yaw") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and ui.get(lua.def.yaw_type) == "Breaker" and has_access)

        ui.set_visible(lua.def.spacer3, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.label2, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.spacer4, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.variation, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.flick_type, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.flick_rate, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access and ui.get(lua.def.flick_type) == "Custom")
        ui.set_visible(lua.def.start_degree, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.trigger_pitch, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.nodspeed, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access and ui.get(lua.def.start_degree) == 6)
        ui.set_visible(lua.def.unpred_flick, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and  ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.spacer5, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.label3, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.spacer6, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.pause_time, sync_defensive_desync and getcombo(lua.def.override_def, "Override Pitch") and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)


        freesync_cust_stat = ui.get(lua.def.freesync.yaw_type) == "Custom (Jitter)" or ui.get(lua.def.freesync.yaw_type) == "Custom (Static)"
        freesync_cust_jitt = ui.get(lua.def.freesync.yaw_type) == "Custom (Jitter)"
        
        ui.set_visible(lua.def.freesync.conditions, ui.get(lua.def.def_type) == "Free-sync" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.freesync.yaw_type, ui.get(lua.def.def_type) == "Free-sync" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.freesync.c_yaw_degree, ui.get(lua.def.def_type) == "Free-sync" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access and freesync_cust_stat)
        ui.set_visible(lua.def.freesync.c_yaw_jitter_degree, ui.get(lua.def.def_type) == "Free-sync" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access and freesync_cust_jitt)
        ui.set_visible(lua.def.freesync.pitch_type, ui.get(lua.def.def_type) == "Free-sync" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.freesync.c_pitch_degree, ui.get(lua.def.def_type) == "Free-sync" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access and ui.get(lua.def.freesync.pitch_type) == "Custom")



        local doubleorsingle = ui.get(lua.def.flick.multiple_flicks) == "Double" or ui.get(lua.def.flick.multiple_flicks) == "Single"
        -- Flick Thingy

        ui.set_visible(lua.def.flick.yp_drop, ui.get(lua.def.def_type) == "Experimental Yaw Flicks" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.flick.multiple_flicks, ui.get(lua.def.def_type) == "Experimental Yaw Flicks" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.flick.firstflick, doubleorsingle and ui.get(lua.def.def_type) == "Experimental Yaw Flicks" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.flick.first_custom_degree, doubleorsingle and ui.get(lua.def.flick.firstflick) == "Custom" and ui.get(lua.def.def_type) == "Experimental Yaw Flicks" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.flick.secondflick, is_second_check and ui.get(lua.def.def_type) == "Experimental Yaw Flicks" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.flick.second_custom_degree, is_second_check and ui.get(lua.def.flick.secondflick) == "Custom" and ui.get(lua.def.def_type) == "Experimental Yaw Flicks" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.flick.quad_addon, not doubleorsingle and ui.get(lua.def.flick.multiple_flicks) == "Random" and ui.get(lua.def.def_type) == "Experimental Yaw Flicks" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.flick.regularity, ui.get(lua.def.def_type) == "Experimental Yaw Flicks" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.flick.freesync_res, ui.get(lua.def.def_type) == "Experimental Yaw Flicks" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.flick.custom_fcres,ui.get(lua.def.flick.freesync_res) == "Custom" and ui.get(lua.def.def_type) == "Experimental Yaw Flicks" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)
        ui.set_visible(lua.def.flick.pitch, ui.get(lua.def.flick.yp_drop) == "Yaw & Pitch" and ui.get(lua.def.def_type) == "Experimental Yaw Flicks" and ui.get(lua.home.manager) == "\aFFDF62FF⚠ \aE8E8E8FFDefensive AA" and ui.get(lua.def.toggle) and has_access)


        ui.set_visible(antiaim[1].ovr_state, false)
    




    ui.set_visible(deny_register, login_details.is_visible and login_details.is_registered == false)
    ui.set_visible(confirm_register, login_details.is_visible and login_details.is_registered == false)
    ui.set_visible(double_check_register, not login_details.is_visible and login_details.is_registered == false)
end



local function vector_angles(start_x, start_y, start_z, dest_x, dest_y, dest_z)
    local origin_x, origin_y, origin_z
    local target_x, target_y, target_z
    if dest_x == nil then
        target_x, target_y, target_z = start_x, start_y, start_z
        origin_x, origin_y, origin_z = client.eye_position()
        if origin_x == nil then
            return
        end
    else
        origin_x, origin_y, origin_z = start_x, start_y, start_z
        target_x, target_y, target_z = dest_x, dest_y, dest_z
    end

    local delta_x, delta_y, delta_z = target_x-origin_x, target_y-origin_y, target_z-origin_z

    if delta_x == 0 and delta_y == 0 then
        return 0, (delta_z > 0 and 270 or 90)
    else
        local yaw = math_deg(math_atan2(delta_y, delta_x))

        local hyp = math_sqrt(delta_x*delta_x + delta_y*delta_y)
        local pitch = math_deg(math_atan2(-delta_z, hyp))

        return pitch, yaw
    end
end


local var = {
    side,
    body_yaw = 0,
    switch = false,
    legit_aa = false,
    got_left = false,
    got_right = false,
    rollroyse = false,
    clantag_restore = false,
    ground = 0,
    mode = nil,
    anti_backstab = false,
    build = "stable"
}

local def_vars = {
    is_true = false,
    set_loop = 0,
    exp_ticks = 0,
    pitch_variation = 0,
    spin_fix = 0,
    base = 0,
    latest_duck = 0,
    current_mag_amount = 0,
    correct_mag_timer = 0,
    jitter_switch = false,
    selfhand_fs = false,
    slow_timer = 0,
    closeenemy = "",
    lpred = 0,
    rpred = 0,

    defensive = {
        cmd = 0,
        check = 0,
        defensive = 0,
    },

    selectjitter = false,

    fs_istrue = false
}
local function height_to_pitch()
    local enemy = client.current_threat()
    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then
        return
    end



end


local function keep_updt()
    def_vars.is_true = false
    def_vars.selfhand_fs = false
    def_vars.fs_istrue = false
    def_vars.selectjitter = false
    if entity.get_local_player() == nil then return end
    local lp = entity.get_local_player()
end
local time_to_ticks = function(t)
    return math.floor(t / globals.tickinterval() + 0.5)
end

local aa_table = {
    side = 0,
    last_rand = 0,
    skitter_counter = 0,
    last_skitter = 0,
    last_count = 0,
    cycle = 0
}







local nade_alpha = 0
local animate_text = function(time, string, r, g, b, a)
    local t_out, t_out_iter = { }, 1

    local l = string:len( ) - 1

    local r_add = (255 - r)
    local g_add = (255 - g)
    local b_add = (255 - b)
    local a_add = (195 - a)

    for i = 1, #string do
        local iter = (i - 1)/(#string - 1) + time
        t_out[t_out_iter] = "\a" .. func._2hex( r + r_add * math.abs(math.cos( iter )), g + g_add * math.abs(math.cos( iter )), b + b_add * math.abs(math.cos( iter )), (a  - nade_alpha) + a_add * math.abs(math.cos( iter )) )

        t_out[t_out_iter + 1] = string:sub( i, i )

        t_out_iter = t_out_iter + 2
    end

    return t_out
end



get_player_state = function (self)

    local localplayer = entity.get_local_player()
    if not localplayer then
        return ""
    end
    local flags = entity.get_prop(localplayer, "m_fFlags");
    local weapon = entity.get_player_weapon(localplayer);
    local x, y, z = entity.get_prop(localplayer, "m_vecVelocity");
    velocity = math.sqrt(x * x + y * y + z * z);
    if not weapon then
        return "", false;
    end

    if bit.band(flags, 1) == 0 then
        var.ground = 0
    elseif var.ground <= 5 then
        var.ground = var.ground + 1
    end

    local in_air = var.ground <= 5;
    local duckamount = entity.get_prop(localplayer, "m_flDuckAmount");
    local slowmotion = ui.get(menu.slowmotion[1]) and ui.get(menu.slowmotion[2]);

    if in_air and duckamount > 0 then
        return "Air-Duck";
    elseif in_air then
        return "Air";
    elseif ui.get(menu.fakeduck) or duckamount > 0 and not in_air then
        return "Duck";
    elseif slowmotion and velocity > 4 then
        return "Slow Motion";
    elseif velocity > 4 then
        return "Running";
    else
        return "Standing";
    end
end


local function func_timer()

    def_vars.correct_mag_timer = def_vars.correct_mag_timer + 0.5
    if def_vars.correct_mag_timer < 10 and getcombo(lua.def.def_conds, "On Shot") then
        def_vars.is_true = true
    end

end


local function on_shot()
    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then
        return
    end
    local weapon = entity.get_player_weapon(lp)

    def_vars.correct_mag_timer = 0
end


local function on_land()
    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then
        return
    end
    local self_index = c_entity.new(lp)
    local self_anim_state = self_index:get_anim_state()
    if not self_anim_state then
        return
    end
    if self_anim_state.hit_in_ground_animation and getcombo(lua.def.def_conds, "When Landing") then
        def_vars.is_true = true
    end
end





local function on_unduck()
    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then
        return
    end
    local duck_amount = entity.get_prop(lp, "m_flDuckAmount")
    local duck_diff = duck_amount - def_vars.latest_duck
    def_vars.latest_duck = duck_amount

    if duck_diff < 0 and getcombo(lua.def.def_conds, "Unduck") then
        def_vars.is_true = true
    end
end

local function get_lc(cmd)
    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then
        return
    end
    local last_origin = vector(0, 0, 0)

    local origin = vector(entity.get_origin(lp))
    local breaking_lc = (last_origin - origin):length2dsqr() > 4096


    if cmd.chokedcommands == 0 then
        last_origin = origin
    end


end


local function pre_prediction_logic()
    l_dmg, r_dmg, c_dmg = 0, 0, 0

	local local_player = get_local_player()
	if local_player == nil or not entity.is_alive(local_player) then
		return
	end

	local v_origin_local = Vector3(get_prop(local_player, "m_vecAbsOrigin"))
	if v_origin_local.x == nil then
		return
	end

	local v_eye_local = Vector3(client.eye_position())
	if v_eye_local.x == nil then
		return
	end

	local players = get_all_players(true)

	local closestplayer = nil
	local pitch, yaw, roll = client.camera_angles()
	local cam_angle = Vector3(0, yaw, 0)

	local fov = 180

	for i=1, #players do
		local entindex = players[i]
		if entity_is_enemy(entindex) and entity_is_alive(entindex) and not entity_is_dormant(entindex) then
			local v_origin_enemy = Vector3(entity.get_prop(entindex, "m_vecOrigin"))
			local cur_fov = get_FOV(cam_angle, v_origin_local, v_origin_enemy)
			if cur_fov < fov then
				fov = cur_fov
				closestplayer = entindex
			end
		end
	end

	local v_origin_enemy = Vector3(entity.get_prop(closestplayer, "m_vecOrigin"))

	local at_pitch, at_yaw = vector_angles(v_origin_local.x, v_origin_local.y, v_origin_local.z, v_origin_enemy.x, v_origin_enemy.y, v_origin_enemy.z)

	cam_angle = Vector3(at_pitch, at_yaw, 0)

	if closestplayer ~= nil then
		local v_viewoffset_enemy = Vector3(entity.get_prop(closestplayer, "m_vecViewOffset"))

		local v_eye_enemy = v_origin_enemy + v_viewoffset_enemy

		local l_id, r_id, c_id = 0, 0		

		local l_add, r_add = o_scan_fineness, o_scan_fineness
		local a_left = -angle_right(cam_angle)
		local a_right = angle_right(cam_angle)

		v_left = v_eye_local + a_left * l_add
		v_right = v_eye_local + a_right * r_add
		
		local v_head_local_x, v_head_local_y, v_head_local_z = entity.hitbox_position(local_player, 0)

		c_id, c_dmg = client.trace_bullet(closestplayer, v_eye_enemy.x, v_eye_enemy.y, v_eye_enemy.z, v_head_local_x, v_head_local_y, v_head_local_z)

        --[[
		if c_dmg > 0 then
			return
		end

        ]]

		while l_dmg < 1 and l_add < ui.get(lua.home.fs_sense) do
			v_left = v_eye_local + a_left * l_add
			l_id, l_dmg = client.trace_bullet(closestplayer, v_eye_enemy.x, v_eye_enemy.y, v_eye_enemy.z, v_left.x , v_left.y, v_left.z)
			l_add = l_add + o_scan_fineness
		end

		while r_dmg < 1 and r_add < ui.get(lua.home.fs_sense) do
			v_right = v_eye_local + a_right * r_add
			r_id, r_dmg = client.trace_bullet(closestplayer, v_eye_enemy.x, v_eye_enemy.y, v_eye_enemy.z, v_right.x , v_right.y, v_right.z)
			r_add = r_add + o_scan_fineness
		end
	end

    local vals_tbl = {l_dmg, r_dmg}
    def_vars.lpred = l_dmg
    def_vars.rpred = r_dmg
    
    def_vars.closeenemy = closestplayer
    for i = 1, #vals_tbl do
        if vals_tbl[i] > 0 and getcombo(lua.def.def_conds, "Predict Visible") and c_dmg <= 0 then
            def_vars.is_true = true
        end
        if vals_tbl[i] > 0 and c_dmg <= 0 then
            def_vars.selfhand_fs = true
        end

        if vals_tbl[i] > 0 and c_dmg <= 0 then
            def_vars.selectjitter = true
        end


        if vals_tbl[i] > 0 and getcombo(lua.def.freesync.conditions, "Smart") and c_dmg <= 0 then
            def_vars.fs_istrue = true
        end


    end

    if c_dmg > 0 and getcombo(lua.def.def_conds, "Visible") then
        def_vars.is_true = true
    end


end








local pre = {
    tick_delay,
    switch_tick,
    switch,
    choke_hold,
    multiplier = 1.2,
    start_time = globals.realtime()

}

local lp_choke = 0

local function Presets(arg)
    arg.force_defensive = false
    ui.set(menu.freestanding_body_yaw, false)

    if ui.get(lua.preset.force_def) then
        arg.force_defensive = arg.command_number % 3 ~= 1 or arg.weaponselect ~= 0 or arg.quick_stop == 1
    end

    if not ui.get(aa_type) == "Presets" then return end
    ui.set(menu.pitch[2], 89)
    ui.set(menu.pitch[1], "Custom")


    if ui.get(lua.preset.pre_type) == "Meta Jitter" then
        ui.set(menu.yaw[2], 12)
        ui.set(menu.yaw_jitter[1], "Center")
        ui.set(menu.yaw_jitter[2], 62)
        ui.set(menu.body_yaw[1], "Jitter")
        ui.set(menu.body_yaw[2], 1)
        ui.set(menu.roll, 0)
    elseif ui.get(lua.preset.pre_type) == "Delayed" then
        
        ui.set(menu.yaw_jitter[1], "off")
        ui.set(menu.body_yaw[1], "static")
        if arg.command_number % (ui.get(lua.preset.delay)+1+1) == 1 then
            tbl.antiaim.ready = true
        end
        if tbl.antiaim.ready and arg.chokedcommands == 0 then
            local fake = (60+1) * 2
            tbl.antiaim.ready = false
            tbl.antiaim.evade_fake = not tbl.antiaim.evade_fake
            ui.set(menu.body_yaw[2], tbl.antiaim.evade_fake and -fake or fake)

            if tbl.antiaim.evade_fake then
                ui.set(menu.yaw[2], clamp(ui.get(lua.preset.right)))
            else
                ui.set(menu.yaw[2], clamp(ui.get(lua.preset.left)))

            end

        end



        ui.set(menu.roll, 0)


    elseif ui.get(lua.preset.pre_type) == "evade Special" then



        local current_time = globals.realtime()
        local r_t = (1 + math.cos((current_time - pre.start_time) * (14))) / 2
        if r_t > 0.5 then
            ui.set(menu.yaw[2], -16)
            ui.set(menu.body_yaw[2], -180)
        else
            ui.set(menu.yaw[2], 47)
            ui.set(menu.body_yaw[2], 180)
        end
        ui.set(menu.yaw_jitter[1], "Center")
        ui.set(menu.yaw_jitter[2], 0)
        ui.set(menu.body_yaw[1], "Static")
        ui.set(menu.roll, 0)
    end
end


getstate = function(air, duck, speed, slowcheck)
    local state = 1
    if air and duck then state = 6 end
    if air and not duck then state = 5 end
    if duck and not air then state = 7 end
    if speed < 60 and not air and not duck then state = 2 end
    if speed > 60 and not air and not duck then state = 3 end
    if slowcheck and not air and not duck then state = 4 end
    return state
end

local jitter_histories = {}
local desync_tracking = {}
local yaw_state = 1  -- 1 or -1 to track current side

-- Utility functions
local function normalize_angle(angle)
    while angle > 180 do angle = angle - 360 end
    while angle < -180 do angle = angle + 360 end
    return angle
end

local function vector_distance(x1, y1, z1, x2, y2, z2)
    return math.sqrt((x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2)
end

-- Enhanced target selection
local function get_target()
    local local_player = entity.get_local_player()
    if not local_player or not entity.is_alive(local_player) then return nil end

    local players = entity.get_players(true)
    if #players == 0 then return nil end

    local best_target = nil
    local best_distance = math.huge
    local view_x, view_y, view_z = client.eye_position()

    for i=1, #players do
        local player = players[i]
        if entity.is_alive(player) and not entity.is_dormant(player) then
            local x, y, z = entity.get_origin(player)
            if x then  -- Check if origin is valid
                local distance = vector_distance(view_x, view_y, view_z, x, y, z)
                
                if distance < best_distance then
                    best_distance = distance
                    best_target = player
                end
            end
        end
    end

    return best_target
end

local function detect_jitter_pattern(target)
    if not target then return nil end
    if entity.is_dormant(target) then
        jitter_histories[target] = nil
        return nil
    end
    
    if not jitter_histories[target] then
        jitter_histories[target] = {
            yaws = {},
            body_yaws = {},
            last_update = 0
        }
    end
    
    local history = jitter_histories[target]
    local eye_yaw = entity.get_prop(target, "m_angEyeAngles[1]")
    local anim_state = entity.get_prop(target, "m_flPoseParameter", 11)
    
    if not eye_yaw or not anim_state then return nil end
    
    local body_yaw = (anim_state * 116 - 58)
    
    table.insert(history.yaws, eye_yaw)
    table.insert(history.body_yaws, body_yaw)
    
    if #history.yaws > 8 then
        table.remove(history.yaws, 1)
        table.remove(history.body_yaws, 1)
    end
    
    if #history.yaws >= 4 then
        local max_yaw = -180
        local min_yaw = 180
        
        for i=1, #history.yaws do
            local yaw = history.yaws[i]
            max_yaw = math.max(max_yaw, yaw)
            min_yaw = math.min(min_yaw, yaw)
        end
        
        local jitter_range = math.abs(max_yaw - min_yaw)
        
        local body_alternating = true
        for i=2, #history.body_yaws do
            if math.abs(history.body_yaws[i] - history.body_yaws[i-1]) < 30 then
                body_alternating = false
                break
            end
        end
        
        if jitter_range > 5 and jitter_range < 120 and body_alternating then
            return {
                is_jittering = true,
                range = jitter_range,
                center = normalize_angle(min_yaw + jitter_range/2),
                body_alternating = body_alternating
            }
        end
    end
    
    return nil
end

local function detect_desync_side(target)
    if not target then return 0 end
    
    -- Get pose parameter for body yaw
    local pose_param = entity.get_prop(target, "m_flPoseParameter", 11)
    if not pose_param then return 0 end

    -- Get body yaw offset
    local body_yaw = (pose_param * 116 - 58)
    
    -- Initialize tracking for this target
    if not desync_tracking[target] then
        desync_tracking[target] = {
            last_body_yaw = body_yaw,
            switch_count = 0,
            last_check = globals.tickcount(),
            is_jittering = false
        }
    end
    
    local tracking = desync_tracking[target]
    
    -- Check for rapid switches
    local curr_tick = globals.tickcount()
    if curr_tick - tracking.last_check > 2 then
        if math.abs(body_yaw - tracking.last_body_yaw) > 30 then
            tracking.switch_count = tracking.switch_count + 1
        end
        
        -- If we see multiple switches, it's jittering
        if tracking.switch_count >= 2 then
            tracking.is_jittering = true
        end
        
        tracking.last_body_yaw = body_yaw
        tracking.last_check = curr_tick
    end
    
    -- If we detected jitter, alternate the desync side each tick
    if tracking.is_jittering then
        return (globals.tickcount() % 2 == 0) and -1 or 1  -- Inverted
    end

    -- Otherwise return based on current body yaw (inverted)
    return body_yaw > 0 and -1 or 1  -- Inverted
end
-- Then modify get_target_angles to use this simpler detection:
local function get_target_angles(target)
    if not target then return nil end
    if not entity.is_alive(target) then return nil end
    
    local local_player = entity.get_local_player()
    if not local_player or not entity.is_alive(local_player) then return nil end

    -- Get raw angles with safety checks
    local raw_yaw = entity.get_prop(target, "m_angEyeAngles[1]")
    local raw_pitch = entity.get_prop(target, "m_angEyeAngles[0]")
    if not raw_yaw or not raw_pitch then return nil end

    -- Detect desync pattern and jitter
    local desync_side = detect_desync_side(target)
    local is_jittering = desync_tracking[target] and desync_tracking[target].is_jittering or false

    -- If jittering detected, use jitter mode
    if is_jittering then
        yaw_state = yaw_state * -1
        return {
            real = 32 * yaw_state,
            pitch = 89,
            is_jittering = true,
            desync_side = yaw_state * 1
        }
    end

    -- If not jittering, use standard angle mirroring
    local mirrored_yaw = math.min(math.max(raw_yaw, -60), 60)
    
    return {
        real = mirrored_yaw,
        pitch = 89,
        is_jittering = false,
        desync_side = desync_side
    }
end



local left_irreg = 0
local right_irreg = 0
local global_irreg = 0

local function Builder(arg)
    if not ui.get(aa_type) == "Builder" then return end
    ui.set(menu.pitch[2], 89)
    ui.set(menu.pitch[1], "Custom")
    local lp = entity.get_local_player()
    local air = bit.band(entity.get_prop(lp, "m_fFlags"), 1) == 0
    local xv, yv, zv = entity.get_prop(lp, "m_vecVelocity")
    local duck = (entity.get_prop(lp, "m_flDuckAmount") > 0.1)
    local team = (entity.get_prop(lp, "m_iTeamNum") == 2 and "t" or "ct")
    local vvelocity = math.sqrt(xv*xv + yv*yv + zv*zv)

    



    local real_state = getstate(arg.in_jump == 1 or air, duck, math.sqrt(xv*xv + yv*yv + zv*zv), (ui.get(menu.slowmotion[1]) and ui.get(menu.slowmotion[2])))
    local state = real_state
    if ui.get(antiaim[state]["ovr_state"]) ~= true then
        state = 1
    end
    if ui.get(antiaim[state]["force_def"]) then
        arg.force_defensive = arg.command_number % 3 ~= 1 or arg.weaponselect ~= 0 or arg.quick_stop == 1
    else
        arg.force_defensive = false
    end

    if ui.get(antiaim[state]["irregulization"]) == "Step" then
        if left_irreg < ui.get(antiaim[state]["left_irreg_amount"]) then
            left_irreg = left_irreg + (0.75 + (ui.get(antiaim[state]["left_irreg_amount"]) * 0.05))
        end

        if left_irreg > ui.get(antiaim[state]["left_irreg_amount"]) then
            left_irreg = 0
        end

        if right_irreg < ui.get(antiaim[state]["right_irreg_amount"]) then
            right_irreg = right_irreg + (0.75 + (ui.get(antiaim[state]["right_irreg_amount"]) * 0.05))
        end

        if right_irreg > ui.get(antiaim[state]["right_irreg_amount"]) - 1 then
            right_irreg = 0
        end

        if global_irreg < ui.get(antiaim[state]["global_irreg_amount"]) then
            global_irreg = global_irreg + (0.75 + (ui.get(antiaim[state]["global_irreg_amount"]) * 0.05))
        end

        if global_irreg > ui.get(antiaim[state]["global_irreg_amount"]) - 1 then
            global_irreg = 0
        end

    elseif ui.get(antiaim[state]["irregulization"]) == "Randomize" then

        left_irreg = math.random(1, ui.get(antiaim[state]["left_irreg_amount"]))

        right_irreg = math.random(1, ui.get(antiaim[state]["right_irreg_amount"]))

        global_irreg = math.random(1, ui.get(antiaim[state]["global_irreg_amount"]))

    end



    if ui.get(antiaim[state]["body_movement"]) == "Default" then

        ui.set(menu.yaw[2], ui.get(antiaim[state]["b_yaw"]) + global_irreg)

    elseif ui.get(antiaim[state]["body_movement"]) == "Jitter" then
        local yaw_body = entity.get_prop(lp, "m_flPoseParameter", 11) * 120 - 60 <= 0
        local body_value = false
        if yaw_body then
            body_value = true
        end
        if math.max(-60, math.min(60, math.floor((entity.get_prop(lp,"m_flPoseParameter", 11) or 0)*120-60+0.5))) > 0 then
            ui.set(menu.body_yaw[2], -1)
            ui.set(menu.yaw[2], clamp(ui.get(antiaim[state]["b_yaw"]) - (ui.get(antiaim[state]["b_left"]) * 1) + left_irreg))
        else
            ui.set(menu.body_yaw[2], 1)
            ui.set(menu.yaw[2], clamp(ui.get(antiaim[state]["b_yaw"]) - (ui.get(antiaim[state]["b_right"]) * 1) + right_irreg))
        end

    elseif ui.get(antiaim[state]["body_movement"]) == "Slow" then


        ui.set(menu.yaw_jitter[1], "off")
        ui.set(menu.body_yaw[1], "static")
        if arg.command_number % (ui.get(antiaim[state]["b_delay"])+1+1) == 1 then
            tbl.antiaim.ready = true
        end
        if arg.command_number % ui.get(antiaim[state]["switch_timer"])+1+1 > ui.get(antiaim[state]["switch_timer"])+1+1 then
            if arg.command_number % (ui.get(antiaim[state]["b_delay1"])+1+1   + math.min(math.random(ui.get(antiaim[state]["variation"]), 0), 5)) == 1 then
                tbl.antiaim.ready1 = true
            end
        else
            if arg.command_number % (ui.get(antiaim[state]["b_delay2"])+1+1   + math.min(math.random(ui.get(antiaim[state]["variation"]), 0), 5)) == 1 then
                tbl.antiaim.ready1 = true
            end
        end

        if arg.command_number % (ui.get(antiaim[state]["switch_timer"])+1+1) * 3 > ui.get(antiaim[state]["switch_timer"]+1+1) * 3 then
            if arg.command_number % math.random(2, 7) == 1 then
                tbl.antiaim.ready2 = true
            end
        else
            if arg.command_number % math.random(2, 7) == 1 then
                tbl.antiaim.ready2 = true
            end
        end
        
        if ui.get(antiaim[state]["slow_type"]) == "Single" then
            if tbl.antiaim.ready and arg.chokedcommands == 0 then
                local fake = (ui.get(antiaim[state]["fake"])+3) * 2
                tbl.antiaim.ready = false
                tbl.antiaim.evade_fake = not tbl.antiaim.evade_fake
                ui.set(menu.body_yaw[2], tbl.antiaim.evade_fake and -fake or fake)

                if tbl.antiaim.evade_fake then
                    ui.set(menu.yaw[2], clamp(ui.get(antiaim[state]["b_right"]) + ui.get(antiaim[state]["b_yaw"]) + right_irreg))
                else
                    ui.set(menu.yaw[2], clamp(ui.get(antiaim[state]["b_left"]) + ui.get(antiaim[state]["b_yaw"]) + left_irreg))
                end

            end
        elseif ui.get(antiaim[state]["slow_type"]) == "Double" then
            if tbl.antiaim.ready1 and arg.chokedcommands == 0 then
                local fake = (ui.get(antiaim[state]["fake"])+3) * 2
                tbl.antiaim.ready1 = false
                tbl.antiaim.evade_fake = not tbl.antiaim.evade_fake
                ui.set(menu.body_yaw[2], tbl.antiaim.evade_fake and -fake or fake)

                if tbl.antiaim.evade_fake then
                    ui.set(menu.yaw[2], clamp(ui.get(antiaim[state]["b_right"]) + ui.get(antiaim[state]["b_yaw"]) + right_irreg))
                else
                    ui.set(menu.yaw[2], clamp(ui.get(antiaim[state]["b_left"]) + ui.get(antiaim[state]["b_yaw"]) + left_irreg))
                end
            end
        elseif ui.get(antiaim[state]["slow_type"]) == "Unpredictive" then
            if tbl.antiaim.ready2 and arg.chokedcommands == 0 then
                local fake = (ui.get(antiaim[state]["fake"])+3) * 2
                tbl.antiaim.ready2 = false
                tbl.antiaim.evade_fake = not tbl.antiaim.evade_fake
                ui.set(menu.body_yaw[2], tbl.antiaim.evade_fake and -fake or fake)

                if tbl.antiaim.evade_fake then
                    ui.set(menu.yaw[2], clamp(ui.get(antiaim[state]["b_right"]) + ui.get(antiaim[state]["b_yaw"]) + right_irreg))
                else
                    ui.set(menu.yaw[2], clamp(ui.get(antiaim[state]["b_left"]) + ui.get(antiaim[state]["b_yaw"]) + left_irreg))
                end
            end
        
        end


    elseif ui.get(antiaim[state]["body_movement"]) == "AI" then
        if arg.chokedcommands == 0 then
            local angles
            local target = get_target()
            if target and not entity.is_dormant(target) then
                angles = get_target_angles(target)
                            local final_yaw = math.min(math.max(angles.real or 0, -60), 60)
            ui.set(menu.yaw[2], final_yaw)
            
            -- Apply fake using simplified desync side
            ui.set(menu.body_yaw[1], "Static")
            ui.set(menu.body_yaw[2], angles.desync_side or -1)
            end

        end
    end

    if ui.get(antiaim[state]["jitter_type"]) == "Off" then
        ui.set(menu.yaw_jitter[1], "Off")
        ui.set(menu.yaw_jitter[2], 0)
    elseif ui.get(antiaim[state]["jitter_type"]) == "Offset" then
        ui.set(menu.yaw_jitter[1], "Offset")
        ui.set(menu.yaw_jitter[2], ui.get(antiaim[state]["j_rad"]))
    elseif ui.get(antiaim[state]["jitter_type"]) == "Center" then
        ui.set(menu.yaw_jitter[1], "Center")
        ui.set(menu.yaw_jitter[2], ui.get(antiaim[state]["j_rad"]))
    elseif ui.get(antiaim[state]["jitter_type"]) == "Stomp" then
        ui.set(menu.yaw_jitter[1], "Center")
        ui.set(menu.yaw_jitter[2], (ui.get(antiaim[state]["j_rad"]) + math.random(1, 11)))
    end


    if getcombo(lua.aa_additions.additions, "Select Jitter") and def_vars.selectjitter == true and vvelocity > 120 then
        ui.set(menu.body_yaw[1], "static")
        local yaw_body = entity.get_prop(lp, "m_flPoseParameter", 11) * 120 - 60 <= 0
        local body_value = false
        if yaw_body then
            body_value = true
        end
        if math.max(-60, math.min(60, math.floor((entity.get_prop(lp,"m_flPoseParameter", 11) or 0)*120-60+0.5))) > 0 then
            ui.set(menu.body_yaw[2], -1)
            ui.set(menu.yaw[2], clamp(ui.get(antiaim[state]["b_yaw"]) - (49 * 1) + left_irreg))
        else
            ui.set(menu.body_yaw[2], 1)
            ui.set(menu.yaw[2], clamp(ui.get(antiaim[state]["b_yaw"]) - (-36 * 1) + right_irreg))
        end
    end



end






local def_states_table = {
    "Standing",
    "Air-Duck",
    "Air",
    "Running",
    "Duck",
}


local new_def_table = {

    "Air",
    "Duck",

}
local pitch_num = {

    1,
    2,
    3
}

local pitch_str = {
    89,
    45,
    0, 
    -45,
    -89,
    88
}
client.set_event_callback("pre_config_load", function(e)
    client.reload_active_scripts(true)
end)
client.set_event_callback("run_command", function(e)

    keep_updt()
    pre_prediction_logic()
    func_timer()

    def_vars.defensive.cmd = e.command_number
end)

local setup_defensive = {

    yaw = 0,
    body_offset = 0,
    side_counter = 0,
    side = 0,
    cycle = 0,
    hold = 0,
    hold_ready = false

}


client.set_event_callback("predict_command", function(e)
    if e.command_number == def_vars.defensive.cmd then
        local tickbase = entity.get_prop(entity.get_local_player(), "m_nTickBase")
        
        def_vars.defensive.defensive = math.abs(tickbase - def_vars.defensive.check)
        def_vars.defensive.check = math.max(tickbase, def_vars.defensive.check or 0)
        def_vars.defensive.cmd = 0
    end
end)
local pitchnod_func = 0
client.set_event_callback("level_init", function() def_vars.defensive.check, def_vars.defensive.defensive = 0, 0 end)
local freesync_timer = 0
local unpred_timer = 0
local spinner = {
    current_angle = 0,  -- Tracks the true 360 degree angle
    last_update = globals.realtime()
}


local function defensive_logic(arg)
    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then
        return
    end
    local weapon = entity.get_player_weapon(lp)
        
    if not ui.get(lua.def.toggle) or not ui.get(lua.def.def_type) == "Desync" then return end


    local lag_timer = entity.get_prop(lp, "m_nTickbase") % ui.get(lua.def.pause_time) == 0
    local air = bit.band(entity.get_prop(lp, "m_fFlags"), 1) == 0
    local isDefensive = (def_vars.defensive.defensive > 1 and def_vars.defensive.defensive < 14)
    local sv_tick = globals.tickcount()
    local current_time = globals.realtime()
    local pitch_variable = ((1 + math.cos((current_time - pre.start_time) * 40)) / 2) * 360
    local slow_yaw_var = ((1 + math.cos((current_time - pre.start_time) * (ui.get(lua.def.delay) * 4))) / 2) * 30
    local xv, yv, zv = entity.get_prop(lp, "m_vecVelocity")
    local vvelocity = math.sqrt(xv*xv + yv*yv + zv*zv)
    local compensate_camera = client.camera_angles() - 360
    arg.force_defensive = false
    local view_x, view_y, roll = client.camera_angles();
    lp_choke = lp_choke + 1 * pre.multiplier

    if lp_choke > 60 then
        lp_choke = 0
    end


    if setup_defensive.cycle == ui.get(lua.def.delay) then
        delayed = false
        setup_defensive.side = setup_defensive.side == 1 and 0 or 1
    end


    if ui.get(lua.def.spin_radius) > 340 then
        def_vars.spin_fix = ui.get(lua.def.spin_radius) - 23
    else
        def_vars.spin_fix = ui.get(lua.def.spin_radius)
    end
    if def_vars.set_loop <= def_vars.spin_fix then
        def_vars.set_loop = def_vars.set_loop + 1 + ui.get(lua.def.delay) * 8
    end
    if def_vars.set_loop > def_vars.spin_fix then
        def_vars.set_loop = 0
    end



    local yaw_val = (def_vars.set_loop - def_vars.spin_fix / 2)

    if ui.get(lua.def.spin_direction) == 1 then
        yaw_val = (-def_vars.set_loop + def_vars.spin_fix / 2)
    end

    if ui.get(lua.def.disrupt_spin) then
        local aut_test = math.random(1, 20)
        if aut_test <= 10 then
            yaw_val = (-def_vars.set_loop + def_vars.spin_fix / 2)
        else
            yaw_val = (def_vars.set_loop - def_vars.spin_fix / 2)
        end
    end



    local current_time = globals.realtime()
    local time_delta = current_time - spinner.last_update
    
    -- Update angle based on speed
    spinner.current_angle = spinner.current_angle + ((ui.get(lua.def.delay) * 200) * time_delta)
    
    -- Keep angle within 0-360 range
    spinner.current_angle = spinner.current_angle % ui.get(lua.def.spin_radius)
    
    -- Convert to game-friendly -180/180 range and set yaw
    def_vars.base = func.normalize_angle(spinner.current_angle)

    
    spinner.last_update = current_time



    for i = 1, #def_states_table do
        
        if get_player_state() == def_states_table[i] and getcombo(lua.def.def_conds, def_states_table[i]) == true or ui.get(menu.slowmotion[2]) then
            def_vars.is_true = true
        end


        if ui.get(menu.doubletap[2]) then 
            if ui.get(lua.def.freesync_updt) then
                if freesync_timer < 10 then
                    def_vars.is_true = false
                end
                if freesync_timer > 20 then
                    freesync_timer = 0
                end
            end
            if def_vars.is_true == true and not ui.get(menu.fakeduck) then 
                if getcombo(lua.def.override_def, "Override Yaw") then 



                    arg.allow_send_packet = true
                     
                    ui.set(menu.doubletap[3], "Defensive")

                    if globals.tickcount() % 3 == 1 then
                        ui.set(menu.doubletap[3], "Offensive")
                    end
                    arg.force_defensive = false
                    if ui.get(lua.def.pause_time) > 0 then
                        arg.force_defensive = false
                    end
                    if air and ui.get(lua.def.pause_time) > 0 then
                        
                        ui.set(menu.fakeduck, lag_timer and "Always on" or "On hotkey")
                        ui.set(menu.ragebot_toggle, false)
                    end

                    if arg.chokedcommands == 0 then
                        if setup_defensive.cycle >= ui.get(lua.def.delay) then
                            setup_defensive.cycle = 1
                        else
                            setup_defensive.cycle = setup_defensive.cycle + 1
                        end
                    end

                    local current_time = globals.realtime()
                    ui.set(menu.yaw_jitter[1], "Center")
                    ui.set(menu.yaw_jitter[2], 0)
                    ui.set(menu.body_yaw[1], "Off")
                    ui.set(menu.body_yaw[2], 1)
                    ui.set(menu.roll, 0)

                    if ui.get(lua.def.def_hold_switch) then
                        if arg.command_number % ui.get(lua.def.def_hold) >= ui.get(lua.def.def_hold) / 2 then
                            setup_defensive.hold_ready = true
                        end
                    else
                        setup_defensive.hold_ready = true
                    end

                    if setup_defensive.hold_ready == true then
                        arg.force_defensive = true
                        setup_defensive.hold_ready = false
                        if ui.get(lua.def.yaw_type) == "Static" then
                            ui.set(menu.yaw[2], ui.get(lua.def.yaw))
                            ui.set(menu.yaw_jitter[2], 0)
                        elseif ui.get(lua.def.yaw_type) == "Jitter" then
                            ui.set(menu.yaw[2], ui.get(lua.def.yaw))
                            ui.set(menu.yaw_jitter[1], "Center")
                            ui.set(menu.yaw_jitter[2], ui.get(lua.def.radius) * 2.5)
                            ui.set(menu.body_yaw[1], "Jitter")
                            ui.set(menu.body_yaw[2], 1)

                        elseif ui.get(lua.def.yaw_type) == "Breaker" then
                            -- Pre-defined base angles
                            local left_angle = -125
                            local right_angle = 135
                        
                            -- Use statement1 for delay timing
                            local statement1 = ui.get(lua.def.breaker_statement1)
                            local switch_timer = statement1 * 2
                            local tick_count = globals.tickcount()
                        
                            -- Use statement2 for yaw radius adjustment
                            local statement2 = ui.get(lua.def.breaker_statement2)
                            -- Adjust angles based on statement2
                            if statement2 > 0 then
                                right_angle = right_angle + statement2
                                left_angle = left_angle - statement2
                            else
                                right_angle = right_angle - math.abs(statement2)
                                left_angle = left_angle + math.abs(statement2)
                            end
                        
                            -- Determine if it's time to switch
                            if tick_count % switch_timer == 0 then
                                if setup_defensive.side_counter >= 2 then
                                    setup_defensive.side_counter = 0
                                else
                                    setup_defensive.side_counter = setup_defensive.side_counter + 1
                                end
                            end
                            
                            -- Smoother random variation based on tick
                            local random_variation = math.sin(tick_count * 0.1) * 5
                        
                            if ui.get(lua.def.breaker_sequence) == "Unpure" then
                                -- Smooth randomization for unpure mode
                                local unpure_random = math.sin(tick_count * 0.2) * 15
                                left_angle = left_angle + unpure_random
                                right_angle = right_angle - unpure_random
                            end
                        
                            -- Calculate target yaw
                            local target_yaw
                            if setup_defensive.side_counter == 0 then
                                target_yaw = left_angle + random_variation
                            else
                                target_yaw = right_angle + random_variation
                            end
                        
                            -- Smooth transition to target
                            if not setup_defensive.last_yaw then
                                setup_defensive.last_yaw = target_yaw
                            end
                        
                            -- Smoothing factor based on statement1
                            local smooth_factor = 0.1 + (statement1 * 0.01)
                            setup_defensive.yaw = setup_defensive.last_yaw + (target_yaw - setup_defensive.last_yaw) * smooth_factor
                            setup_defensive.last_yaw = setup_defensive.yaw
                        
                            -- Apply yaw if in defensive mode
                            if isDefensive then
                                local final_yaw = func.normalize(setup_defensive.yaw)
                                ui.set(menu.yaw[2], final_yaw)
                            end
                        
                            -- Set additional AA parameters
                            ui.set(menu.body_yaw[1], "Static")
                            ui.set(menu.yaw_jitter[2], 0)
                        elseif ui.get(lua.def.yaw_type) == "Spin" then
                            if isDefensive then

                                
                                ui.set(menu.yaw[2], func.normalize_angle(def_vars.base))
                                ui.set(menu.yaw_jitter[2], 0)
                                ui.set(menu.body_yaw[1], "Static")
                                ui.set(menu.body_yaw[2], 0)
                            end
                        end
                    end
                end






                for i = 1, #pitch_str do
                    if getcombo(lua.def.override_def, "Override Pitch") then 
                        ui.set(menu.pitch[1], "Custom")
                        ui.set(menu.pitch[2], pitch_str[ui.get(lua.def.start_degree)])

                        local isptr = false
                        local exp_delay_ticks = time_to_ticks(ui.get(lua.def.flick_rate) / 10)
                        def_vars.exp_ticks = (def_vars.exp_ticks + 1) % (exp_delay_ticks + 1)

                        if ui.get(menu.pitch[2], pitch_str[ui.get(lua.def.trigger_pitch)]) == 88 then
                            isptr = true
                        end

                        local exp_half_delay_ticks = math.floor(exp_delay_ticks / 2)
                        exp_switch = def_vars.exp_ticks < exp_half_delay_ticks
                        if def_vars.pitch_variation < 50 then
                            def_vars.pitch_variation = def_vars.pitch_variation + 2
                        end

                        if def_vars.pitch_variation >= ui.get(lua.def.variation) then
                            def_vars.pitch_variation = 0
                        end

                        

                        if pitchnod_func > -88 then 
                            pitchnod_func = pitchnod_func - ui.get(lua.def.nodspeed) / 100
                        end

                        if pitchnod_func < -80 then
                            pitchnod_func = 89
                        end
                        if ui.get(lua.def.flick_type) == "evade" then
                            if isDefensive then
                                ui.set(menu.pitch[2], pitch_str[ui.get(lua.def.trigger_pitch)])
                                ui.set(menu.pitch[1], "Custom")
                            end
                        else
                            if isDefensive then
                                if exp_switch == false and ui.get(lua.def.flick_rate) ~= 0 then
           
                                    ui.set(menu.pitch[2], pitch_str[ui.get(lua.def.trigger_pitch)])
                                    ui.set(menu.pitch[1], "Custom")
        
                                end
                            end
                        end

                        if ui.get(lua.def.unpred_flick) then
                            if isDefensive then
                                if arg.chokedcommands == 1 then
                                    unpred_timer = unpred_timer + 0.25
                                end

                                if unpred_timer <= 1.25 then
                                    ui.set(menu.pitch[1], "Up")
                                end

                                if unpred_timer > 8 then
                                    unpred_timer = 0
                                end
                            end
                        end
                        if isDefensive and isptr == true then

                            ui.set(menu.pitch[2], pitchnod_func)
                        end
                    end
                end
            end
        end 
    end
end

fffL = 0

local flickvars = {

    flickways = fffL,
    is_freesync = false,
    waysmemory = 0,
    waysadder = 1,
    waysreset = 3,
    can_execute = false,
    extrapolate = 0,
    pitchflick = false,
    logtimer = 0,
    logval = 0,
    quadval = 0,
    sixteenval = 0,
    set_loop = 0,
    spin_fix = 0,
    set_spin_yaw = 0,
    breaker_ready = false

    
}

local function freesync_and_flick(arg)

    

    if not ui.get(lua.def.toggle) then return end


    local isDefensive = (def_vars.defensive.defensive > 1 and def_vars.defensive.defensive < 14)
    local sv_tick = globals.tickcount()
    local current_time = globals.realtime()
    local pitch_variable = ((1 + math.cos((current_time - pre.start_time) * 40)) / 2) * 360
    local slow_yaw_var = ((1 + math.cos((current_time - pre.start_time) * (ui.get(lua.def.delay) * 4))) / 2) * 30
    local compensate_camera = client.camera_angles() - 360
    local view_x, view_y, roll = client.camera_angles();
    if arg.chokedcommands == 1 then
        lp_choke = lp_choke + 1 * pre.multiplier
    end
    if lp_choke > 60 then
        lp_choke = 0
    end
    
    arg.force_defensive = false

    if arg.chokedcommands > 1 then
        arg.allow_send_packet = false
    else
        arg.allow_send_packet = true
    end 
    arg.force_defensive = globals.tickcount() % 3 ~= 1

    if globals.chokedcommands() == 0 and setup_defensive.cycle == ui.get(lua.def.delay) then
        delayed = false
        setup_defensive.side = setup_defensive.side == 1 and 0 or 1
    end

    if get_player_state() == "Air" or get_player_state() == "Air-Duck" then
        if getcombo(lua.def.freesync.conditions, "Jumping") then
            def_vars.fs_istrue = true
        end
    end

    if get_player_state() == "Duck" and getcombo(lua.def.freesync.conditions, "Lower Body Angles") then
        def_vars.fs_istrue = true
    end
    if arg.chokedcommands == 1 then
        freesync_timer = freesync_timer + 0.5
    end

    if freesync_timer < 10 then
        def_vars.fs_istrue = false
    end
    if freesync_timer > 20 then
        freesync_timer = 0
    end

    if isDefensive and def_vars.fs_istrue == true and arg.chokedcommands == 1 and ui.get(lua.def.def_type) == "Free-Sync" then
        
        ui.set(menu.yaw[2], math.random(0, 100) >= 50 and 120 or -120)
        ui.set(menu.yaw_jitter[1], "Center")
        ui.set(menu.yaw_jitter[2], 0)
        ui.set(menu.body_yaw[1], "Static")
        ui.set(menu.body_yaw[2], 1)
        ui.set(menu.roll, 0)
        ui.set(menu.pitch[1], "Custom")
        ui.set(menu.pitch[2], -50)

    end


    if ui.get(lua.def.def_type) == "Experimental Yaw Flicks" then
        
        --[[
        if ui.get(lua.def.flick.quad_addon) > 340 then
            flickvars.spin_fix = ui.get(lua.def.flick.quad_addon) - 23
        else
            flickvars.spin_fix = ui.get(lua.def.flick.quad_addon)
        end
        if flickvars.set_loop <= flickvars.spin_fix then
            flickvars.set_loop = flickvars.set_loop + 1
        end
        if flickvars.set_loop > flickvars.spin_fix then
            flickvars.set_loop = 0
        end

        flickvars.yaw_val = (flickvars.set_loop - flickvars.spin_fix / 2)

        ]]
        ui.set(menu.pitch[1], "Custom")
        ui.set(menu.pitch[2], 89)
        if ui.get(lua.def.flick.freesync_res) == "Spam" then 
            flickvars.extrapolate = 12
        elseif ui.get(lua.def.flick.freesync_res) == "High" then
            flickvars.extrapolate = 15
        elseif ui.get(lua.def.flick.freesync_res) == "Mid" then
            flickvars.extrapolate = 22
        elseif ui.get(lua.def.flick.freesync_res) == "Custom" then
            flickvars.extrapolate = ui.get(lua.def.flick.custom_fcres)
        else
            flickvars.extrapolate = 30
        end
        flickvars.pitchflick = false
        flickvars.can_execute = false
        -- Flick Funny Stuff Setup
        flickvars.is_freesync = false

        if freesync_timer < 10 then
            flickvars.is_freesync = true
        end
        if freesync_timer > flickvars.extrapolate then
            freesync_timer = 0
        end
        fffL = 0
        fff, fffn = ui.get(lua.def.flick.multiple_flicks) == "Single", 1
        ffs, ffsn = ui.get(lua.def.flick.multiple_flicks) == "Double", 2


        if fff then fffL = fffn end
        if ffs then fffL = ffsn end
        flickvars.logtimer = 0
        if flickvars.logtimer < 40 then 
            flickvars.logtimer = flickvars.logtimer + 0.5
        end

        if flickvars.logtimer > 40 then
            flickvars.logtimer = 0
        end
        flickvars.logval = 21
        local is_freesync_allowed = ui.get(lua.def.flick.regularity) == "Free-Sync" or ui.get(lua.def.flick.regularity) == "Free-Sync+"
        if isDefensive and flickvars.is_freesync == true and is_freesync_allowed then
            flickvars.can_execute = true
            flickvars.waysreset = flickvars.flickways +1

            if flickvars.logtimer > 27 then
                flickvars.logval = 12
            end
            flickvars.waysmemory = flickvars.waysmemory + flickvars.waysadder/flickvars.logval

            if flickvars.waysmemory > flickvars.waysreset then
                flickvars.waysmemory = 0
            end


            flickvars.quadval = ((flickvars.waysmemory + 1) / 2) * 12
            flickvars.quadval = math.floor((flickvars.quadval / 2) - 1.1)


        end

        if isDefensive and ui.get(lua.def.flick.regularity) == "Defensive" then
            flickvars.can_execute = true

            flickvars.waysmemory = arg.chokedcommands % 2
            fffL = math.random(1,2)





        end



        if flickvars.can_execute == true then



            

            if ui.get(lua.def.flick.multiple_flicks) == "Single" or ui.get(lua.def.flick.multiple_flicks) == "Double" then
                if flickvars.waysmemory > 0.7 and fffL == 2 then
                    if ui.get(lua.def.flick.secondflick) == "Left" then
                        ui.set(menu.yaw[2], -90)
                    elseif ui.get(lua.def.flick.secondflick) == "Right" then
                        ui.set(menu.yaw[2], 90)
                    else
                        ui.set(menu.yaw[2], ui.get(lua.def.flick.second_custom_degree))
                    end

                    ui.set(menu.yaw_jitter[1], "Center")
                    ui.set(menu.yaw_jitter[2], 0)
                    ui.set(menu.body_yaw[1], "Static")
                    ui.set(menu.body_yaw[2], 1)
                    ui.set(menu.roll, 0)
                    flickvars.pitchflick = true
                end

                if flickvars.waysmemory > 0.8 and fffL == 1 or flickvars.waysmemory > 0.8 and fffL == 2 then
                    ui.set(menu.yaw[2], 0)
                
                    if ui.get(lua.def.flick.firstflick) == "Left" then
                        ui.set(menu.yaw[2], -90)
                    elseif ui.get(lua.def.flick.firstflick) == "Right" then
                        ui.set(menu.yaw[2], 90)
                    else
                        ui.set(menu.yaw[2], ui.get(lua.def.flick.first_custom_degree))
                    end


                    

                    ui.set(menu.yaw_jitter[1], "Center")
                    ui.set(menu.yaw_jitter[2], 0)
                    ui.set(menu.body_yaw[1], "Static")
                    ui.set(menu.body_yaw[2], 1)
                    ui.set(menu.roll, 0)
                    flickvars.pitchflick = true

                end
            end

            
            if ui.get(lua.def.flick.multiple_flicks) == "Random" then
                flickvars.yaw_val = math.random(ui.get(lua.def.flick.quad_addon), -ui.get(lua.def.flick.quad_addon)) * flickvars.quadval
                if ui.get(lua.def.flick.quad_addon) > 45 and flickvars.quadval > 2 then
                    flickvars.yaw_val = math.random(ui.get(lua.def.flick.quad_addon), -ui.get(lua.def.flick.quad_addon)) * flickvars.quadval
                else
                    flickvars.yaw_val = flickvars.yaw_val
                end

                if flickvars.yaw_val > 180 and flickvars.quadval < 3 then 
                    flickvars.yaw_val = 179
                end

               if flickvars.yaw_val > 180 or flickvars.yaw_val < -180 then return end
                if arg.command_number % 2 == 1 then
                    flickvars.breaker_ready = true
                end
                if flickvars.breaker_ready == true then
                    flickvars.breaker_ready = false
                    ui.set(menu.yaw[2], flickvars.yaw_val)
                end


                ui.set(menu.yaw_jitter[1], "Center")
                ui.set(menu.yaw_jitter[2], 0)
                ui.set(menu.body_yaw[1], "Static")
                ui.set(menu.body_yaw[2], 1)
                ui.set(menu.roll, 0)
                flickvars.pitchflick = true
            end

            
            if flickvars.pitchflick == true and ui.get(lua.def.flick.yp_drop) == "Yaw & Pitch" then
                if ui.get(lua.def.flick.pitch) == "Up" then
                    ui.set(menu.pitch[1], "Custom")
                    ui.set(menu.pitch[2], -88)
                elseif ui.get(lua.def.flick.pitch) == "Semi-Up" then
                    ui.set(menu.pitch[1], "Custom")
                    ui.set(menu.pitch[2], -48)
                else
                    ui.set(menu.pitch[1], "Custom")
                    ui.set(menu.pitch[2], 7)
                end
            end
        end
    end
end

local isdouble_pred = false
local fsindicator = "NIL"

local function disablers()

    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then
        return
    end
    local xv, yv, zv = entity.get_prop(lp, "m_vecVelocity")
    local vvelocity = math.sqrt(xv*xv + yv*yv + zv*zv)

    tbl.antiaim.is_antiknife = false
    if ui.get(aa_type) == "None" then
        ui.set(menu.yaw[2], 0)
        ui.set(menu.yaw_jitter[1], "Center")
        ui.set(menu.yaw_jitter[2], 0)
        ui.set(menu.body_yaw[1], "Off")
        ui.set(menu.body_yaw[2], 1)
        ui.set(menu.roll, 0)
        ui.set(menu.pitch[1], "Custom")
        ui.set(menu.pitch[2], 89)
    end

    -- Hidehead

    local weapon = entity.get_player_weapon(lp)
    local weapon_info = csgo_weapons(weapon)


    if ui.get(lua.home.fs_key) and ui.get(lua.home.fs) then
        ui.set(menu.freestand[1], ui.get(lua.home.fs))
        ui.set(menu.freestand[2], "Always on")
        ui.set(menu.doubletap[3], "Defensive")

        if def_vars.is_true == true and not ui.get(lua.def.ignore_fs) then
            ui.set(menu.pitch[1], "Down")
            ui.set(menu.yaw[2], 0)
            ui.set(menu.body_yaw[1], "Static")
            ui.set(menu.yaw_jitter[2], 0)
        end

        if getcombo(lua.aa_additions.additions, "Static Freestanding") then
            ui.set(menu.pitch[1], "Down")
            ui.set(menu.yaw[2], 0)
            ui.set(menu.body_yaw[1], "Static")
            ui.set(menu.yaw_jitter[2], 0)
            if vvelocity > 100 then
                ui.set(menu.body_yaw[2], -1)
            end
        end

    else
        ui.set(menu.freestand[1], false)
        ui.set(menu.freestand[2], "On hotkey")
    end
    --[[
        if ui.get(lua.home.sh_fs) and def_vars.selfhand_fs == true then
        ui.set(menu.freestand[1], true)
        ui.set(menu.freestand[2], "Always On")
    end
    ]]

    if getcombo(lua.aa_additions.hidehead_drop, "Beta Jitter") then
        if math.random(1, 3) == 3 then
            ui.set(menu.fakepeek[1], true)
            ui.set(menu.fakepeek[2], "Always on")
        else
            ui.set(menu.fakepeek[1], false)
            ui.set(menu.fakepeek[2], "On hotkey")
        end
    end

    if ui.get(lua.home.osaa_key) and ui.get(lua.home.osaa) then
        ui.set(menu.onshot[1], ui.get(lua.home.osaa))
        ui.set(menu.onshot[2], "Always on")
    else
        ui.set(menu.onshot[1], false)
        ui.set(menu.onshot[2], "On hotkey")
    end

    if getcombo(lua.aa_additions.additions, "Hide Head") then
        if getcombo(lua.aa_additions.hidehead_drop, "On Knife") and weapon_info.type == "knife" or getcombo(lua.aa_additions.hidehead_drop, "On Zeus") and weapon_info.type == "taser" then
            ui.set(menu.yaw[2], 20)
            ui.set(menu.yaw_jitter[2], 0)
            ui.set(menu.body_yaw[1], "Static")
            ui.set(menu.body_yaw[2], 1)
        end
    end



    if ui.get(lua.home.shfs_key) and ui.get(lua.home.sh_fs) then
        isdouble_pred = false
        if def_vars.lpred > 1 and def_vars.rpred > 1 then
            isdouble_pred = true
        end
        
        if isdouble_pred == false then
            if def_vars.lpred > 1 then
                fsindicator = "RIGHT"
                ui.set(menu.yaw[2], 103)
            elseif def_vars.rpred > 1 then
                fsindicator = "LEFT"
                ui.set(menu.yaw[2], -103)
            end
        end
    end



    
    



    ---------------------------------------
    -- Anti-Aim Additions -----------------
    ---------------------------------------

    if getcombo(lua.aa_additions.additions, "Anti-Shank") then
        local lp = entity.get_local_player()
        if not lp or not entity.is_alive(lp) then
            return
        end
        local my_origin = vector(entity.get_origin(lp))

        local player_list = entity.get_players(true)
        local player_cnt = #player_list

        local closest_dist, closest_yaw = math.huge, nil

        for i=1, player_cnt do
            local ent = player_list[i]
            local weapon = entity.get_player_weapon(ent)
            local player_origin = vector(entity.hitbox_position(ent, 2))
            local distance = my_origin:dist(player_origin)
            --local visible = client.visible(player_origin:unpack())

            if distance < 350 and weapon ~= nil then
            local weapon_info = csgo_weapons(weapon)

                if weapon_info.is_melee_weapon then
                    if distance < closest_dist then
                        local _, yaw_to_target = (player_origin - my_origin):angles()
                        closest_yaw = yaw_to_target
                        closest_dist = distance
                    end
                end
            end
        end

        if closest_yaw then
            ui.set(menu.yaw[2], 180)
            ui.set(menu.yaw_base, "At targets")
            tbl.antiaim.is_antiknife = true
        end
    end


    -- Hide Head Functions
    

end
local text_dst = 0
local text_spr = 8
local anim1 = 0
local scopeFrac
local scope_anim = 0
local debug_align_stat = 10
local debug_align_multiplier = 0
local dtcol_r = 200
local dtcol_g = 70
local dtcol_b = 70

local anims = {

    dt = 0,
    osaa = 0,
    fd = 0,
    fs = 0,

}


local debugconditions = {
    "",
    "standing",
    "running",
    "slowwalk",
    "air",
    "air-duck",
    "crouching"
}

local anint = {int1 = 0, int2 = 0, int3 = 0, int4 = 0, int5 = 0, int6 = 0, int7 = 0, int8 = 0, int9 = 0, int10 = 0, int11 = 0, int12 = 0, animspeed = 0.2}
local start_anim1 = 0
local start_anim2 = 0
local start_anim3 = 0
local y_anim1 = 0
local y_anim2 = 0

local function indicators(arg)
    local lp = entity.get_local_player()
    local debug_align_stat = 10
    local debug_align_multiplier = 0
    local screensize = { client.screen_size() }
    local center = { screensize[1] / 2, screensize[2] / 2 }
    local screen_x = center[1]
    local screen_y = center[2]
    local ss = { screensize[1] / 2, screensize[2] / 2 }
    local valid = lp ~= nil and entity.is_alive(lp)
    local scoped
    local resume_scope
    if not valid then
        return
    end
    local get_build = string.upper(curr_build)
    local air = bit.band(entity.get_prop(lp, "m_fFlags"), 1) == 0
    local xv, yv, zv = entity.get_prop(lp, "m_vecVelocity")
    local duck = (entity.get_prop(lp, "m_flDuckAmount") > 0.1)
    local team = (entity.get_prop(lp, "m_iTeamNum") == 2 and "t" or "ct")
    local vvelocity = math.sqrt(xv*xv + yv*yv + zv*zv)

    if ui.get(lua.home.shfs_key) and ui.get(lua.home.sh_fs) then
        renderer.indicator(230, 230, 230, 230, "EVADE FS ["..fsindicator.."]")
    end

    local vis_tables = {


        cols = {
            crosshair = { ui.get(lua.visuals.colpick1) },
            other = { ui.get(lua.visuals.colpick2) },
            logs = { ui.get(lua.visuals.colpick3) },

        },
        render_strings = {
            "EVADE  ",
            get_build.." ",
        },
        anims = {
    
            alpha = math.abs(1 * math.cos(2 * math.pi * globals.curtime() / 4)) * (255),
    
        },
    
        nades = {

            "CIncendiaryGrenade",
            "CHEGrenade",
            "CMolotovGrenade",
            "CSmokeGrenade",
        },

        adder = {

            dst = 0,
            spr = 10,

        }
    }



    local real_state = getstate(vvelocity > 260 or air, duck, math.sqrt(xv*xv + yv*yv + zv*zv), (ui.get(menu.slowmotion[1]) and ui.get(menu.slowmotion[2])))
    local state = real_state

    local subt1 = "EVADE"
    local subt2 = "LUA"
    local subt3 = "- "..tostring(debugconditions[state]).." -"
    local subt4 = "CHARGE"
    local subt5 = "FREESTAND"
    local subt6 = "DMG: "..tostring(ui.get(menu.damage_bind[3]))

    local num1 = string.len(subt1)
    local num2 = string.len(subt2)
    local num3 = string.len(subt3)
    local num4 = string.len(subt4)
    local num5 = string.len(subt5)

    local endstring1 = string.sub(subt1, 1, anint.int1)
    local endstring2 = string.sub(subt1, 1, anint.int2)
    local endstring3 = string.sub(subt2, 1, anint.int3)
    local endstring4 = string.sub(subt2, 1, anint.int4)
    local endstring5 = string.sub(subt3, 1, anint.int5)
    local endstring6 = string.sub(subt3, 1, anint.int6)
    local endstring7 = string.sub(subt4, 1, anint.int7)
    local endstring8 = string.sub(subt4, 1, anint.int8)
    local endstring9 = string.sub(subt5, 1, anint.int9)
    local endstring10 = string.sub(subt5, 1, anint.int10)
    local endstring11 = string.sub(subt6, 1, anint.int11)
    local endstring12 = string.sub(subt6, 1, anint.int12)

    local dynastring1 = animate_text(globals.curtime() * 2, endstring1, vis_tables.cols.crosshair[1],vis_tables.cols.crosshair[2],vis_tables.cols.crosshair[3], vis_tables.cols.crosshair[4])
    local dynastring2 = animate_text(globals.curtime() * 2, endstring2, vis_tables.cols.crosshair[1],vis_tables.cols.crosshair[2],vis_tables.cols.crosshair[3], vis_tables.cols.crosshair[4])
    local text_dst = 0
    local text_spr = 8

    local isCharged = anti_aim.get_double_tap()
    local local_overlap = anti_aim.get_overlap()
    local weapon = entity.get_player_weapon(lp)
    local weap_name = entity.get_classname(weapon)

    local nade_alpha = 0

    local m_zoomLevel = entity.get_prop(weapon, 'm_zoomLevel')
    local m_bIsScoped = entity.get_prop(lp, 'm_bIsScoped') == 1
    local m_bResumeZoom = entity.get_prop(lp, 'm_bResumeZoom') == 1

    --[[
    
    
    ]]



    if m_bIsScoped then
        if anint.int1 > 0 then anint.int1 = anint.int1 - anint.animspeed end
        if anint.int2 < num1 then anint.int2 = anint.int2 + anint.animspeed end
        if anint.int3 > 0 then anint.int3 = anint.int3 - anint.animspeed end
        if anint.int4 < num2 then anint.int4 = anint.int4 + anint.animspeed end
        if anint.int5 > 0 then anint.int5 = anint.int5 - anint.animspeed end
        if anint.int6 < num3 then anint.int6 = anint.int6 + anint.animspeed end
        if anint.int7 > 0 then anint.int7 = anint.int7 - anint.animspeed end
        if anint.int8 < num4 then anint.int8 = anint.int8 + anint.animspeed end
        if anint.int9 > 0 then anint.int9 = anint.int9 - anint.animspeed end
        if anint.int10 < num5 then anint.int10 = anint.int10 + anint.animspeed end
        if anint.int11 > 0 then anint.int11 = anint.int11 - anint.animspeed end
        if anint.int12 < num5 then anint.int12 = anint.int12 + anint.animspeed end
    else
        if anint.int1 < num1 then anint.int1 = anint.int1 + anint.animspeed end
        if anint.int2 > 0 then anint.int2 = anint.int2 - anint.animspeed end
        if anint.int3 < num2 then anint.int3 = anint.int3 + anint.animspeed end
        if anint.int4 > 0 then anint.int4 = anint.int4 - anint.animspeed end
        if anint.int5 < num3 then anint.int5 = anint.int5 + anint.animspeed end
        if anint.int6 > 0 then anint.int6 = anint.int6 - anint.animspeed end
        if anint.int7 < num4 then anint.int7 = anint.int7 + anint.animspeed end
        if anint.int8 > 0 then anint.int8 = anint.int8 - anint.animspeed end
        if anint.int9 < num5 then anint.int9 = anint.int9 + anint.animspeed end
        if anint.int10 > 0 then anint.int10 = anint.int10 - anint.animspeed end
        if anint.int11 < num5 then anint.int11 = anint.int11 + anint.animspeed end
        if anint.int12 > 0 then anint.int12 = anint.int12 - anint.animspeed end
    end


    local rect_x = screen_x - 25
    local rect_y = screen_y + 31
    local rect_w = 51
    local rect_h = 4
    local rect_t = 1




    --fstext

    local fs_animate_text = animate_text(globals.curtime() * 1.51, "FREESTAND", vis_tables.cols.crosshair[1],vis_tables.cols.crosshair[2],vis_tables.cols.crosshair[3], vis_tables.cols.crosshair[4])
    if def_vars.selfhand_fs == true and ui.get(lua.home.sh_fs) then
        renderer.text(screen_x + anim1, screen_y - 70, 255, 255, 255, 255 - nade_alpha , "cb", nil, unpack(fs_animate_text))
    end


    for i = 1, #vis_tables.nades do 

        if weap_name == vis_tables.nades[i] then
            nade_alpha = 190
        end
    end



    --active_shit[#active_shit + 1] = ui.get(menu.freestand[1]) and ui.get(menu.freestand[2]) and "FREE"
    --active_shit[#active_shit + 1] = ui.get(menu.fakeduck) and "FDUCKING"

    if not ui.get(lua.visuals.toggle) then return end
    if ui.get(lua.visuals.crosshair) == "Basic" then
        if m_bIsScoped then
            if scope_anim < 22 then
                scope_anim = scope_anim + 0.5
            end
        else
            if scope_anim > 0 then
                scope_anim = scope_anim - 0.5
            end
        end
        local packed_text1 = animate_text(globals.curtime() * 3, "  "..string.upper("EVADE"), vis_tables.cols.crosshair[1], vis_tables.cols.crosshair[2], vis_tables.cols.crosshair[3], vis_tables.cols.crosshair[4] - nade_alpha)
        renderer.text(screen_x - 2 + (scope_anim * 0.9), screen_y + 33, vis_tables.cols.crosshair[1], vis_tables.cols.crosshair[2], vis_tables.cols.crosshair[3], vis_tables.cols.crosshair[4] - nade_alpha, "-c", nil, unpack(packed_text1))
        -- Arrows for indic
        renderer.text(screen_x + (scope_anim * 0.9) + 12, screen_y + 32, 255, 255, 255, math.min(255 - nade_alpha, vis_tables.anims.alpha), "-c", nil, ")")
        renderer.text(screen_x + (scope_anim * 0.9) - 15, screen_y + 32, 255, 255, 255, math.min(255 - nade_alpha, vis_tables.anims.alpha), "-c", nil, "(")


        renderer.text(screen_x + (scope_anim * 0.53), screen_y + 25, 255, 255, 255, math.min(255 - nade_alpha, vis_tables.anims.alpha), "-c", nil, vis_tables.render_strings[2])
        if m_bIsScoped then
            renderer.text(screen_x + (scope_anim * 0.15), screen_y + 36, 190, 190, 190, 210, "-", nil, string.upper(debugconditions[state]))
        else
            renderer.text(screen_x + ((scope_anim * renderer.measure_text("-", debugconditions[state])) * 0.05), screen_y + 41, 190, 190, 190, 210 - nade_alpha, "-c", nil, string.upper(debugconditions[state]))
        end

        if ui.get(menu.doubletap[2]) then
            text_dst = text_dst + text_spr
            dtcol_r = dtcol_r - 1
            if dtcol_r < 150 then dtcol_r = 150 end
            dtcol_g = dtcol_g + 1
            if dtcol_g > 210 then dtcol_g = 210 end
            renderer.text(screen_x + (scope_anim * 0.40), screen_y + 41 + text_dst, dtcol_r, dtcol_g, dtcol_b, 255 - nade_alpha , "-c", nil, "DT")
        else
            dtcol_r = 200
            dtcol_g = 70
            dtcol_b = 70
        end
        if ui.get(menu.freestand[2]) then
            text_dst = text_dst + text_spr
            renderer.text(screen_x + (scope_anim * 0.40), screen_y + 41 + text_dst, 255, 255, 255, 255 - nade_alpha , "-c", nil, "FS")
        end
        if ui.get(menu.fakeduck) then
            text_dst = text_dst + text_spr
            renderer.text(screen_x + (scope_anim * 0.64), screen_y + 41 + text_dst, 255, 255, 255, 255 - nade_alpha , "-c", nil, "DUCK")
        end


    elseif ui.get(lua.visuals.crosshair) == "Modern" then

       
        if m_bIsScoped then
            if scope_anim < 30 then
                scope_anim = scope_anim + 4
            end
        else
            if scope_anim > 0 then
                scope_anim = scope_anim - 4
            end
        end

        renderer.text(screen_x -8, screen_y + 34, 255, 255, 255, 255, "c-", nil, unpack(dynastring1))
        renderer.text(screen_x + 27, screen_y + 34, 255, 255, 255, 255, "c-", nil, unpack(dynastring2))

        renderer.text(screen_x + 13, screen_y + 34, 255, 255, 255, vis_tables.anims.alpha, "c-", nil, endstring3)
        renderer.text(screen_x + 48, screen_y + 34, 255, 255, 255, vis_tables.anims.alpha, "c-", nil, endstring4)


        renderer.text(screen_x + -1, screen_y + 43, 255, 255, 255, 255, "c-", nil, string.upper(endstring5))
        renderer.text(screen_x + 36, screen_y + 43, 255, 255, 255, 255, "c-", nil, string.upper(endstring6))
        local dt_charger = isCharged and "d" or ""

        if ui.get(menu.doubletap[2]) then
			if y_anim1 < 9 then y_anim1 = y_anim1 + 0.5 end
            if y_anim2 < 9 then y_anim2 = y_anim2 + 0.5 end
			if start_anim1 < 255 then
				start_anim1 = start_anim1 + 5
			end
			
            renderer.text(screen_x + -1, screen_y + 52, 155, 191, 69, start_anim1, "c-", nil, endstring7)
            renderer.text(screen_x + 36, screen_y + 52, 155, 191, 69, start_anim1, "c-", nil, endstring8)
		else
			if start_anim1 > 0 then
				start_anim1 = start_anim1 - 255
			end
            renderer.text(screen_x + -1, screen_y + 52, 155, 191, 69, start_anim1, "c-", nil, endstring7)
            renderer.text(screen_x + 36, screen_y + 52, 155, 191, 69, start_anim1, "c-", nil, endstring8)
			if y_anim1 > 0 then y_anim1 = y_anim1 - 0.5 end
            if y_anim2 > 0 then y_anim2 = y_anim2 - 0.5 end
		end


        
        if ui.get(menu.freestand[2]) then
            if y_anim2 < 9 then 
				y_anim2 = y_anim2 + 0.5
			end
			if start_anim2 < 255 then
				start_anim2 = start_anim2 + 5
			end
			
            renderer.text(screen_x + -1, screen_y + 52 + y_anim1, 240, 240, 240, start_anim2, "c-", nil, endstring9)
            renderer.text(screen_x + 36, screen_y + 52 + y_anim1, 240, 240, 240, start_anim2, "c-", nil, endstring10)
		else
            
			if start_anim2 > 0 then
				start_anim2 = start_anim2 - 255
			end
            renderer.text(screen_x + -1, screen_y + 52 + y_anim1, 240, 240, 240, start_anim2, "c-", nil, endstring9)
            renderer.text(screen_x + 36, screen_y + 52 + y_anim1, 240, 240, 240, start_anim2, "c-", nil, endstring10)
			if y_anim2 > 0 then 
				y_anim2 = y_anim2 - 0.5
			end
		end


        if ui.get(menu.damage_bind[2]) then

            renderer.text(screen_x, screen_y + 52 + y_anim2 + y_anim1, 210, 195, 255, 255, "c-", nil, endstring11)
            renderer.text(screen_x + 36, screen_y + 52 + y_anim2 + y_anim1, 210, 195, 255, 255, "c-", nil, endstring12)
        end

    elseif ui.get(lua.visuals.crosshair) == "New" then
        -- Animations for scope
        if m_bIsScoped then
            if scope_anim < 22 then
                scope_anim = scope_anim + 0.5
            end
        else
            if scope_anim > 0 then
                scope_anim = scope_anim - 0.5
            end
        end
    
        -- Core animation values
        local alpha_pulse = math.abs(math.cos(globals.realtime() * 2)) * 255
        local state_text = string.upper(get_player_state())
        
        -- Main EVADE text with dots
        renderer.text(screen_x - 2 + scope_anim, screen_y + 32, 255, 255, 255, 255, "c", nil, "EVADE")
        renderer.text(screen_x - 28 + scope_anim, screen_y + 32, 255, 255, 255, alpha_pulse, nil, nil, "•")
        renderer.text(screen_x + 24 + scope_anim, screen_y + 32, 255, 255, 255, alpha_pulse, nil, nil, "•")
        
        -- State text (5px gap)
        renderer.text(screen_x + scope_anim, screen_y + 42, 200, 200, 200, 255, "c", nil, state_text)
        
        -- DT indicator (5px gap)
        if ui.get(menu.doubletap[2]) then
            renderer.text(screen_x + scope_anim, screen_y + 52, 255, 255, 255, 255, "c", nil, "DT")
        end
        
        -- FS indicator (if needed)
        if ui.get(menu.freestand[2]) then
            renderer.text(screen_x + scope_anim, screen_y + (ui.get(menu.doubletap[2]) and 62 or 52), 255, 255, 255, 255, "c", nil, "FS")
        end
    end



    local weapon_info = csgo_weapons(weapon)
    local air = bit.band(entity.get_prop(lp, "m_fFlags"), 1) == 0
    local xv, yv, zv = entity.get_prop(lp, "m_vecVelocity")
    local vvelocity = math.sqrt(xv * xv + yv * yv + zv * zv)
    local duck = (entity.get_prop(lp, "m_flDuckAmount") > 0.1)
    local team = (entity.get_prop(lp, "m_iTeamNum") == 2 and "t" or "ct")
    local lp_hp = entity.get_prop(lp, 'm_iHealth')

    vhits = play_data.hits
    vmisses = play_data.misses

    vperc = (vhits / vmisses) * 100

    local players = get_all_players(true)

    local real_state = getstate(air, duck, math.sqrt(xv*xv + yv*yv + zv*zv), (ui.get(menu.slowmotion[1]) and ui.get(menu.slowmotion[2])))
    local mainstring = animate_text(globals.curtime(), "//debug panel - evade (debug)", vis_tables.cols.other[1], vis_tables.cols.other[2], vis_tables.cols.other[3], vis_tables.cols.other[4])

    if getcombo(lua.visuals.other, "Debug Panel") then
        renderer.text(screen_x * 1.5, screen_y / 2.7, 255, 255, 255, math.abs(1 * math.cos(2 * math.pi * globals.curtime() / 4)) * (220), nil, nil, unpack(mainstring))
        if anti_aim.get_tickbase_shifting() > 1 then
            debug_align_multiplier = debug_align_multiplier + debug_align_stat
            renderer.text(screen_x * 1.5, screen_y / 2.7 + debug_align_multiplier, 255, 255, 255, 220, nil, nil, "tickbase shifting: "..anti_aim.get_tickbase_shifting())
        end
        renderer.text(screen_x * 1.5, screen_y / 2.7 + 10 + debug_align_multiplier, 255, 255, 255, 220, nil, nil, "current weapon type: "..weapon_info.type)
        renderer.text(screen_x * 1.5, screen_y / 2.7 + 20 + debug_align_multiplier, 255, 255, 255, 220, nil, nil, "desync peak value: "..math.floor(anti_aim.get_desync(1)))
        renderer.text(screen_x * 1.5, screen_y / 2.7 + 30 + debug_align_multiplier, 255, 255, 255, 220, nil, nil, "movement state: "..debugconditions[real_state])

        if getcombo(lua.aa_additions.additions, "Anti-Shank") and tbl.antiaim.is_antiknife == true then
            debug_align_multiplier = debug_align_multiplier + debug_align_stat
            renderer.text(screen_x * 1.5, screen_y / 2.7 + 30 + debug_align_multiplier, 255, 180, 180, 220, nil, nil, "anti-shank active")
        end

        renderer.text(screen_x * 1.5, screen_y / 2.7 + 40 + debug_align_multiplier, 255, 255, 255, 220, nil, nil, "velocity: "..math.floor(vvelocity))
        renderer.text(screen_x * 1.5, screen_y / 2.7 + 50 + debug_align_multiplier, lp_hp <= 92 and 255 or 200, lp_hp <= 92 and 180 or 255, lp_hp <= 92 and 180 or 200, 220, nil, nil, lp_hp <= 92 and "is local lethal: true" or "is local lethal: false")
        renderer.text(screen_x * 1.5, screen_y / 2.7 + 60 + debug_align_multiplier, 255, 255, 255, 220, nil, nil, "hitratio: "..play_data.hm_ratio.."%")
    end






end
local function lerp_color(c1, c2, t)
    local r = math_floor(c1[1] * (1 - t) + c2[1] * t + 0.5)
    local g = math_floor(c1[2] * (1 - t) + c2[2] * t + 0.5)
    local b = math_floor(c1[3] * (1 - t) + c2[3] * t + 0.5)
    local a = math_floor(c1[4] * (1 - t) + c2[4] * t + 0.5)

    return { r, g, b, a }
end

local function rectangle_gradient(x, y, w, h, precision, t_left, t_right, b_left, b_right)
    if w < h then
        for i = 1, w, precision do
            local t = (i - 1 + 0.5) / (w - 1 + 0.5)
            local clr = lerp_color(t_left, t_right, t)
            local clr2 = lerp_color(b_left, b_right, t)
            renderer.gradient(x + i - 1, y, precision, h, clr[1], clr[2], clr[3], clr[4], clr2[1], clr2[2], clr2[3], clr2[4], false)
        end
    else
        for i = 1, h, precision do 
            local t = (i - 1 + 0.5) / (h - 1 + 0.5)
            local clr = lerp_color(t_left, b_left, t)
            local clr2 = lerp_color(t_right, b_right, t)
            renderer.gradient(x, y + i - 1, w, precision, clr[1], clr[2], clr[3], clr[4], clr2[1], clr2[2], clr2[3], clr2[4], true)
        end
    end
end

local function debug_render()


    local lp = entity.get_local_player()
    local screensize = { client.screen_size() }
    local center = { screensize[1] / 2, screensize[2] / 2 }
    local screen_x = center[1]
    local screen_y = center[2]
    local ss = { screensize[1] / 2, screensize[2] / 2 }
    local valid = lp ~= nil and entity.is_alive(lp)
    if not valid then
        return
    end
    local scoped
    local resume_scope
    local le_log = { ui.get(lua.visuals.colpick3) }
    local weapon = entity.get_player_weapon(lp)
    local weapon_info = csgo_weapons(weapon)
    local air = bit.band(entity.get_prop(lp, "m_fFlags"), 1) == 0
    local xv, yv, zv = entity.get_prop(lp, "m_vecVelocity")
    local vvelocity = math.sqrt(xv * xv + yv * yv + zv * zv)
    local duck = (entity.get_prop(lp, "m_flDuckAmount") > 0.1)
    local team = (entity.get_prop(lp, "m_iTeamNum") == 2 and "t" or "ct")
    local lp_hp = entity.get_prop(lp, 'm_iHealth')
    local aalpha = math.abs(1 * math.cos(2 * math.pi * globals.curtime() / 4)) * (255)



    -- Watermark--------------
    if not ui.get(lua.info.disablelogs) then
        renderer.circle(screen_x * 2 - 180, 21, 50, 50, 50, 255, 10, 180, 0.5)
        renderer.circle(screen_x * 2 - 30, 21, 50, 50, 50, 255, 10, 0, 0.5)
        renderer.rectangle(screen_x * 2 - 180, 11, 150, 19, 50, 50, 50, 255)
        -- Overlay

        renderer.circle_outline(screen_x * 2 - 180, 21, le_log[1], le_log[2], le_log[3], 80, 10, 90, 0.5, 1)
        renderer.circle_outline(screen_x * 2 - 30, 21, le_log[1], le_log[2], le_log[3], 80, 10, 270, 0.5, 1)

        


        --Glow1-----------------------------------------------------
        renderer.circle_outline(screen_x * 2 - 180, 21, le_log[1], le_log[2], le_log[3], 100, 11, 90, 0.5, 1)
        renderer.circle_outline(screen_x * 2 - 30, 21, le_log[1], le_log[2], le_log[3], 100, 11, 270, 0.5, 1)
        renderer.rectangle(screen_x * 2 - 180, 10, 150, 1, le_log[1], le_log[2], le_log[3], 100)
        renderer.rectangle(screen_x * 2 - 180, 31, 150, 1, le_log[1], le_log[2], le_log[3], 100)
        --Glow2
        renderer.circle_outline(screen_x * 2 - 180, 21, le_log[1], le_log[2], le_log[3], 85, 12, 90, 0.5, 1)
        renderer.circle_outline(screen_x * 2 - 30, 21, le_log[1], le_log[2], le_log[3], 85, 12, 270, 0.5, 1)
        renderer.rectangle(screen_x * 2 - 180, 9, 150, 1, le_log[1], le_log[2], le_log[3], 85)
        renderer.rectangle(screen_x * 2 - 180, 32, 150, 1, le_log[1], le_log[2], le_log[3], 85)
        --Glow3
        renderer.circle_outline(screen_x * 2 - 180, 21, le_log[1], le_log[2], le_log[3], 70, 13, 90, 0.5, 1)
        renderer.circle_outline(screen_x * 2 - 30, 21, le_log[1], le_log[2], le_log[3], 70, 13, 270, 0.5, 1)
        renderer.rectangle(screen_x * 2 - 180, 8, 150, 1, le_log[1], le_log[2], le_log[3], 70)
        renderer.rectangle(screen_x * 2 - 180, 33, 150, 1, le_log[1], le_log[2], le_log[3], 70)
        --Glow4
        renderer.circle_outline(screen_x * 2 - 180, 21, le_log[1], le_log[2], le_log[3], 55, 14, 90, 0.5, 1)
        renderer.circle_outline(screen_x * 2 - 30, 21, le_log[1], le_log[2], le_log[3], 55, 14, 270, 0.5, 1)
        renderer.rectangle(screen_x * 2 - 180, 7, 150, 1, le_log[1], le_log[2], le_log[3], 55)
        renderer.rectangle(screen_x * 2 - 180, 34, 150, 1, le_log[1], le_log[2], le_log[3], 55)
        --Glow5
        renderer.circle_outline(screen_x * 2 - 180, 21, le_log[1], le_log[2], le_log[3], 40, 15, 90, 0.5, 1)
        renderer.circle_outline(screen_x * 2 - 30, 21, le_log[1], le_log[2], le_log[3], 40, 15, 270, 0.5, 1)
        renderer.rectangle(screen_x * 2 - 180, 6, 150, 1, le_log[1], le_log[2], le_log[3], 40)
        renderer.rectangle(screen_x * 2 - 180, 35, 150, 1, le_log[1], le_log[2], le_log[3], 40)
        --Glow6
        renderer.circle_outline(screen_x * 2 - 180, 21, le_log[1], le_log[2], le_log[3], 30, 16, 90, 0.5, 1)
        renderer.circle_outline(screen_x * 2 - 30, 21, le_log[1], le_log[2], le_log[3], 30, 16, 270, 0.5, 1)
        renderer.rectangle(screen_x * 2 - 180, 5, 150, 1, le_log[1], le_log[2], le_log[3], 30)
        renderer.rectangle(screen_x * 2 - 180, 36, 150, 1, le_log[1], le_log[2], le_log[3], 30)
        --Glow7
        renderer.circle_outline(screen_x * 2 - 180, 21, le_log[1], le_log[2], le_log[3], 20, 17, 90, 0.5, 1)
        renderer.circle_outline(screen_x * 2 - 30, 21, le_log[1], le_log[2], le_log[3], 20, 17, 270, 0.5, 1)
        renderer.rectangle(screen_x * 2 - 180, 4, 150, 1, le_log[1], le_log[2], le_log[3], 20)
        renderer.rectangle(screen_x * 2 - 180, 37, 150, 1, le_log[1], le_log[2], le_log[3], 20)
        --Glow8
        renderer.circle_outline(screen_x * 2 - 180, 21, le_log[1], le_log[2], le_log[3], 15, 18, 90, 0.5, 1)
        renderer.circle_outline(screen_x * 2 - 30, 21, le_log[1], le_log[2], le_log[3], 15, 18, 270, 0.5, 1)
        renderer.rectangle(screen_x * 2 - 180, 3, 150, 1, le_log[1], le_log[2], le_log[3], 15)
        renderer.rectangle(screen_x * 2 - 180, 38, 150, 1, le_log[1], le_log[2], le_log[3], 15)
        --Glow9
        renderer.circle_outline(screen_x * 2 - 180, 21, le_log[1], le_log[2], le_log[3], 10, 19, 90, 0.5, 1)
        renderer.circle_outline(screen_x * 2 - 30, 21, le_log[1], le_log[2], le_log[3], 10, 19, 270, 0.5, 1)
        renderer.rectangle(screen_x * 2 - 180, 2, 150, 1, le_log[1], le_log[2], le_log[3], 10)
        renderer.rectangle(screen_x * 2 - 180, 39, 150, 1, le_log[1], le_log[2], le_log[3], 10)


        renderer.rectangle(screen_x * 2 - 180, 11, 150, 1, le_log[1], le_log[2], le_log[3], 80)
        renderer.rectangle(screen_x * 2 - 180, 30, 150, 1, le_log[1], le_log[2], le_log[3], 80)

        -- Anims
        renderer.circle_outline(screen_x * 2 - 180, 21, le_log[1], le_log[2], le_log[3],  math.min(vvelocity / 1.3, 255), 10, 90, math.min(vvelocity / 300, 0.5), 1)
        renderer.circle_outline(screen_x * 2 - 30, 21, le_log[1], le_log[2], le_log[3],  math.min(vvelocity / 1.3, 255), 10, 270, math.min(vvelocity / 300, 0.5), 1)

        renderer.rectangle(screen_x * 2 - 180, 11, 150, 1, le_log[1], le_log[2], le_log[3], math.min(vvelocity / 1.3, 255))
        renderer.rectangle(screen_x * 2 - 180, 30, math.min(vvelocity / 3, 150), 1, le_log[1], le_log[2], le_log[3], math.min(vvelocity / 1.3, 255))


        -- Over top for anim
        renderer.rectangle(screen_x * 2 - 180, 11, 150 - math.min(vvelocity / 3, 150), 1, 50, 50, 50, 255)
        renderer.rectangle(screen_x * 2 - 180, 11, 150 - math.min(vvelocity / 3, 150), 1, le_log[1], le_log[2], le_log[3], 80)


        renderer.text(screen_x*2 - 181, 14, math.min(le_log[1] + 40, 255), math.min(le_log[2] + 40, 255), math.min(le_log[3] + 40, 255), aalpha, "d", nil, "evade")

        renderer.text(screen_x*2 - 181 + renderer.measure_text("d", "evade    "), 14, 255, 255, 255, 255, "d", nil, "<>")
        renderer.text(screen_x*2 - 181 + renderer.measure_text("d", "evade    <>    "), 14, 190, 190, 190, 255, "d", nil, string.lower(curr_build))
        renderer.text(screen_x*2 - 181 + renderer.measure_text("d", "evade    <>    "..string.lower(curr_build).."    "), 14, 255, 255, 255, 255, "d", nil, "<>")
        renderer.text(screen_x*2 - 181 + renderer.measure_text("d", "evade    <>    "..string.lower(curr_build).."    <>    "), 14, 190, 190, 190, 255, "d", nil, "ms: "..math.floor(client.real_latency() * 100) )
    end
    --------------------------

    if flickvars.can_execute == true then
        renderer.gradient(screen_x - 25, screen_y / 3 - 7, 54, 25, 255, 255, 255, 90, 230, 190, 190, 20, true)
            --roofs
            renderer.rectangle(screen_x - 27, screen_y / 3 - 8, 58, 2, 160, 160, 160, 220)
            renderer.rectangle(screen_x + 1, screen_y / 3 + 17, 2, 2, 166, 160, 160, 220)
        
            -- bottom yaw roof
            renderer.rectangle(screen_x + 3, screen_y / 3 + 17, 28, 2, ui.get(menu.yaw[2]) > 0 and 255 or 90, 90, 90, 220)
            renderer.rectangle(screen_x - 27, screen_y / 3 + 17, 28, 2, ui.get(menu.yaw[2]) < 0 and 255 or 90, 90, 90, 220)
            --walls
            renderer.rectangle(screen_x - 27, screen_y / 3 - 6, 2, 23, 160, 160, 160, 220)
            renderer.rectangle(screen_x + 29, screen_y / 3 - 6, 2, 23, 160, 160, 160, 220)

        renderer.text(screen_x, screen_y / 3, 255, 110, 110, 255, "-c", nil, "DEF // BREAK")
        renderer.text(screen_x, screen_y / 3 + 10, 255, 110, 110, 255, "-c", nil, string.upper(ui.get(lua.def.flick.multiple_flicks)))
    end
end
--[[
local function indicators()

    local localplayer = entity.get_local_player()
    local screensize = { client.screen_size() }
    local center = { screensize[1] / 2, screensize[2] / 2 }
    local screen_x = center[1]
    local screen_y = center[2]
    local ss = { screensize[1] / 2, screensize[2] / 2 }
    local valid = localplayer ~= nil and entity.is_alive(localplayer)
    local scoped
    local resume_scope

    if not valid then
        return
    end
    local local_overlap = anti_aim.get_overlap()

    local rect_x = screen_x - 25
    local rect_y = screen_y + 28
    local rect_w = 50
    local rect_h = 4
    local rect_t = 1

    local measure_text1 = renderer.measure_text("-c", "DESYNC DEG ")
    renderer.text(screen_x - 10, screen_y + 22, 255, 255, 255, 255, "-c", nil, "DESYNC DEG ")
    renderer.text(screen_x - 24 + measure_text1, screen_y + 22, 174, 176, 235, 255, "-c", nil, math.floor(local_overlap * 60).."."..math.random(0, 9))
    renderer.rectangle(screen_x - 25, screen_y + 28, local_overlap * rect_w, 3, 255, 255, 255, 255)

    -- Outline
    renderer.rectangle(rect_x, rect_y, rect_w - rect_t, rect_t, 30, 30, 30, 255)
    renderer.rectangle(rect_x, rect_y + rect_t, rect_t, rect_h - rect_t, 30, 30, 30, 255)
    renderer.rectangle(rect_x + rect_w - rect_t, rect_y, rect_t, rect_h - rect_t, 30, 30, 30, 255)
    renderer.rectangle(rect_x + rect_t, rect_y + rect_h - rect_t, rect_w - rect_t, rect_t, 30, 30, 30, 255)

end
]]





client.set_event_callback("aim_fire", function()

    on_shot()

end)

client.set_event_callback("pre_render", function()

    on_land()
end)


client.set_event_callback("setup_command", function(arg)

    
    ui.set(menu.fakeduck, "On hotkey")
    ui.set(menu.ragebot_toggle, true)
    get_lc(arg)
    on_unduck()
    if ui.get(aa_type) == "Builder" then
        Builder(arg)
    end
    if ui.get(aa_type) == "Presets" then
        Presets(arg)
    end
    defensive_logic(arg)
    freesync_and_flick(arg)
    disablers()
end)




-- Auto-save button
auto_save = ui.new_button("AA", "Anti-aimbot angles", "\aE8E8E8FFPush current settings on \aBBC0F3FFload", function()
    local config = {
        menu = {},
        lua = {
            preset = {},
            aa_additions = {},
            def = {},
            home = {},
            visuals = {}
        },
        antiaim = {}
    }

    -- Save menu elements
    for key, value in pairs(menu) do
        if type(value) == "table" then
            config.menu[key] = {}
            for i, element in ipairs(value) do
                if type(element) ~= "userdata" and type(element) ~= "function" then
                    local success, result = pcall(ui.get, element)
                    if success then
                        config.menu[key][i] = result
                    end
                end
            end
        else
            if type(value) ~= "userdata" and type(value) ~= "function" then
                local success, result = pcall(ui.get, value)
                if success then
                    config.menu[key] = result
                end
            end
        end
    end

    -- Save lua elements
    for _, section in ipairs({"preset", "aa_additions", "def", "home", "visuals"}) do
        for key, value in pairs(lua[section]) do
            if type(value) ~= "userdata" and type(value) ~= "function" then
                -- Special handling for visual section color pickers
                if section == "visuals" and (key == "colpick1" or key == "colpick2" or key == "colpick3") then
                    local r, g, b, a = ui.get(value)
                    config.lua[section][key] = {r = r, g = g, b = b, a = a}
                else
                    local success, result = pcall(ui.get, value)
                    if success then
                        config.lua[section][key] = result
                    end
                end
            end
        end
    end

    -- Save antiaim states
    for i = 1, #states do
        config.antiaim[i] = {}
        for key, value in pairs(antiaim[i]) do
            if type(value) ~= "userdata" and type(value) ~= "function" then
                local success, result = pcall(ui.get, value)
                if success then
                    config.antiaim[i][key] = result
                end
            end
        end
    end

    -- Save config with error handling
    local success, err = pcall(function()
        writefile("evade_autosave.txt", json.stringify(config))
    end)

    if success then
        notify.new_bottom(255, 255, 255, {{"Pushed current settings to "}, {"\"on-load\"", true}, {"!"}})
    else
        notify.new_bottom(255, 255, 255, {{"Failed to save config"}})
    end
end)

-- Main load function
local function autosave_func()
    if readfile("evade_autosave.txt") == nil then
        return
    end

    local success, config = pcall(function()
        return json.parse(readfile("evade_autosave.txt"))
    end)

    if not success then
        notify.new_bottom(255, 255, 255, {{"Failed to load config"}})
        return
    end

    -- Load menu elements
    for key, value in pairs(config.menu or {}) do
        if menu[key] then
            if type(menu[key]) == "table" then
                for i, setting in ipairs(value) do
                    if menu[key][i] and type(setting) ~= "userdata" and type(setting) ~= "function" then
                        pcall(ui.set, menu[key][i], setting)
                    end
                end
            else
                if type(value) ~= "userdata" and type(value) ~= "function" then
                    pcall(ui.set, menu[key], value)
                end
            end
        end
    end

    -- Load lua elements
    for _, section in ipairs({"preset", "aa_additions", "def", "home", "visuals"}) do
        for key, value in pairs(config.lua[section] or {}) do
            if lua[section][key] then
                -- Special handling for visual section color pickers
                if section == "visuals" and (key == "colpick1" or key == "colpick2" or key == "colpick3") then
                    if type(value) == "table" and value.r and value.g and value.b and value.a then
                        pcall(ui.set, lua[section][key], value.r, value.g, value.b, value.a)
                    end
                else
                    if type(value) ~= "userdata" and type(value) ~= "function" then
                        pcall(ui.set, lua[section][key], value)
                    end
                end
            end
        end
    end

    -- Load antiaim states
    for i = 1, #states do
        if config.antiaim[i] then
            for key, value in pairs(config.antiaim[i]) do
                if antiaim[i][key] and type(value) ~= "userdata" and type(value) ~= "function" then
                    pcall(ui.set, antiaim[i][key], value)
                end
            end
        end
    end

    notify.new_bottom(255, 255, 255, {{"Settings Loaded!"}})
    print("Your Saved Settings Have Successfully Been Force Loaded")
end

-- Load command handler
client.set_event_callback("console_input", function(text)
    if ui.get(lua.info.disablelogs) then return end
    
    if text == "/load" then
        autosave_func()
    end
end)

-- Initial load on script start
autosave_func()

client.set_event_callback("paint_ui", function()
    ui.set(menu.enabled, true)
    on_load()
    db_load()
    local has_access = login_details.access == true

    ui.set_visible(auto_save, ui.get(lua.home.manager) == "\aBBC0F3FF⚙️ \aE8E8E8FFConfig System")

    ui.set_visible(login_menu.no_access_msg1, login_details.access == false and login_details.is_registered == true)
    ui.set_visible(login_menu.login_spacer, login_details.access == false and login_details.is_registered == true)
    ui.set_visible(login_menu.user_label, login_details.access == false and login_details.is_registered == true)
    ui.set_visible(login_menu.enter_user, login_details.access == false and login_details.is_registered == true)
    ui.set_visible(login_menu.pass_label, login_details.access == false and login_details.is_registered == true)
    ui.set_visible(login_menu.enter_pass, login_details.access == false and login_details.is_registered == true)
    ui.set_visible(login_button, login_details.access == false and login_details.is_registered == true)

    ui.set_visible(login_menu.no_register_label, login_details.access == false and login_details.is_registered == false)
    ui.set_visible(login_menu.register_spacer1, login_details.access == false and login_details.is_registered == false)
    ui.set_visible(login_menu.user_label2, login_details.access == false and login_details.is_registered == false)
    ui.set_visible(login_menu.enter_user2, login_details.access == false and login_details.is_registered == false)
    ui.set_visible(login_menu.pass_label2, login_details.access == false and login_details.is_registered == false)
    ui.set_visible(login_menu.enter_pass2, login_details.access == false and login_details.is_registered == false)
    ui.set_visible(login_menu.key_label2, login_details.access == false and login_details.is_registered == false)
    ui.set_visible(login_menu.key_pass2, login_details.access == false and login_details.is_registered == false)
    ui.set_visible(import_key, login_details.access == false and login_details.is_registered == false)
    ui.set_visible(register_spacer2, login_details.access == false and login_details.is_registered == false)

    --ui.set_visible(no_access_msg2, get_access() == false)
    indicators()
    fix_antiaim_visibility()
    local menu_vis_val = false

    ui.set_visible(menu.fakepeek[1], false);
    ui.set_visible(menu.fakepeek[2], false);
    ui.set_visible(menu.legmovement, false);
    ui.set_visible(menu.slowmotion[1], false);
    ui.set_visible(menu.slowmotion[2], false);
    ui.set_visible(menu.onshot[1], false);
    ui.set_visible(menu.onshot[2], false);
    ui.set_visible(menu.enabled, menu_vis_val);
    ui.set_visible(menu.pitch[1], menu_vis_val);
    ui.set_visible(menu.pitch[2], menu_vis_val);
    ui.set_visible(menu.yaw_base, menu_vis_val);
    ui.set_visible(menu.yaw[1], menu_vis_val);
    ui.set_visible(menu.yaw[2], menu_vis_val);
    ui.set_visible(menu.yaw_jitter[1], menu_vis_val);
    ui.set_visible(menu.yaw_jitter[2], menu_vis_val);
    ui.set_visible(menu.body_yaw[1], menu_vis_val);
    ui.set_visible(menu.body_yaw[2], menu_vis_val);
    ui.set_visible(menu.freestanding_body_yaw, menu_vis_val);
    ui.set_visible(menu.edge_yaw, menu_vis_val);
    ui.set_visible(menu.freestand[1], menu_vis_val);
    ui.set_visible(menu.freestand[2], menu_vis_val);
    ui.set_visible(menu.roll, false);
    ui.set_visible(menu.fakelag_limit, true);

    ui.set_visible(lua.home.label1, has_access)
    ui.set_visible(lua.home.manager, has_access)
    ui.set_visible(lua.home.label2, has_access)
    ui.set_visible(lua.home.label3, has_access)
    ui.set_visible(lua.home.fs, has_access)
    ui.set_visible(lua.home.fs_key, has_access)
    ui.set_visible(lua.home.osaa, has_access)
    ui.set_visible(lua.home.osaa_key, has_access)
    ui.set_visible(lua.home.label4, has_access)
    ui.set_visible(lua.home.hours, has_access)
    ui.set_visible(lua.home.minutes, has_access)
    ui.set_visible(lua.home.seconds, has_access)
    ui.set_visible(lua.home.spacer3, has_access)

    ui.set_visible(lua.info.label1, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.label2, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.label3, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.label4, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.label5, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.label10, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.reset_login, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.get_discord, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.statistics, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.spacer1, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.accuracy, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.misses, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.hits, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)

    ui.set_visible(lua.info.times_missed, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.disablelogs, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.times_hit, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)

    ui.set_visible(lua.info.times_loaded, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)
    ui.set_visible(lua.info.spacer2, ui.get(lua.home.manager) == "\aBBC0F3FF❓ \aE8E8E8FFInfo" and has_access)

    ui.set_visible(lua.visuals.spacer1,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and has_access)
    ui.set_visible(lua.visuals.spacer2,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and has_access)
    ui.set_visible(lua.visuals.spacer3,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and has_access)
    ui.set_visible(lua.visuals.spacer4,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and has_access)
    ui.set_visible(lua.visuals.spacer5,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and has_access)
    ui.set_visible(lua.visuals.spacer6,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and has_access)

    ui.set_visible(lua.visuals.toggle,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals")
    ui.set_visible(lua.visuals.label1,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and ui.get(lua.visuals.toggle) and has_access)
    ui.set_visible(lua.visuals.label2,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and ui.get(lua.visuals.toggle) and has_access)
    ui.set_visible(lua.visuals.label3,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and ui.get(lua.visuals.toggle) and has_access)
    ui.set_visible(lua.visuals.colpick1,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and ui.get(lua.visuals.toggle) and has_access)
    ui.set_visible(lua.visuals.colpick2,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and ui.get(lua.visuals.toggle) and has_access)
    ui.set_visible(lua.visuals.colpick3,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and ui.get(lua.visuals.toggle) and has_access)
    ui.set_visible(lua.visuals.crosshair,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and ui.get(lua.visuals.toggle) and has_access)
    ui.set_visible(lua.visuals.other,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and ui.get(lua.visuals.toggle) and has_access)
    ui.set_visible(lua.visuals.logs,ui.get(lua.home.manager) == "\aBBC0F3FF✎ \aE8E8E8FFVisuals" and ui.get(lua.visuals.toggle) and has_access)
    debug_render()
end)
