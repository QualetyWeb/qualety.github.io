----------------------------------------------------------------
--[[
FROST RESOLVER CREATED BY QUALETY
USAGE OF THIS CODE WITHOUT PERMISSION WILL NOT BE TOLERATED
]]
----------------------------------------------------------------

if writefile then
    if not pcall(readfile, "nn_weights_latest.txt") then
        writefile("nn_weights_latest.txt", "")
    end
end

----------------------------------------------------------------
-- Requirements / Dependencies
----------------------------------------------------------------

local ffi         = require("ffi")
local enhanced_nn = require("enhanced_nn")  -- Your NN module

----------------------------------------------------------------
-- GameSense API shortcuts 
----------------------------------------------------------------

local ui       = ui
local entity   = entity
local client   = client
local globals  = globals
local renderer = renderer
local plist    = plist
local bit      = bit

local band     = bit.band
local sqrt     = math.sqrt
local abs      = math.abs
local deg      = math.deg
local rad      = math.rad
local floor    = math.floor
local max      = math.max
local min      = math.min

----------------------------------------------------------------
-- FFI: vtable entity access 
----------------------------------------------------------------

local vtable_bind = vtable_bind or error("vtable_bind is not available in this environment")

local ent_c = {
    get_client_entity = vtable_bind(
        "client.dll",
        "VClientEntityList003",
        3,
        "void*(__thiscall*)(void*, int)"
    )
}

----------------------------------------------------------------
-- Configurable Offsets
----------------------------------------------------------------

local ANIMSTATE_OFFSET   = 0x9960
local ANIMLAYERS_OFFSET  = 0x2990

----------------------------------------------------------------
-- FFI Structs
----------------------------------------------------------------

ffi.cdef[[
    typedef struct {
        char pad0[0x18];
        float m_flFeetSpeedForwardsOrSideways;  // 0x18
        char pad1[0x34];
        float m_flStopToFullRunningFraction;    // approximate
        char pad2[0xC];
        float m_flEyeYaw;                       // approximate
        float m_flGoalFeetYaw;                  // approximate
        char pad3[0x38];
        float m_flSpeed2D;                      // approximate
    } animation_state_t;

    typedef struct {
        char pad0[0x18];
        unsigned int m_nSequence;
        float m_flPrevCycle;
        float m_flWeight;
        float m_flWeightDeltaRate;
        float m_flPlaybackRate;
        float m_flCycle;
    } animation_layer_t;
]]

----------------------------------------------------------------
-- Global Resolver State Tables
----------------------------------------------------------------

-- Per-entity resolver state (movement history, last resolved angles, etc.)
local resolver_states      = setmetatable({}, { __mode = "k" })

-- Per-entity hit/miss info
local hit_miss_data        = setmetatable({}, { __mode = "k" })

-- Per-entity anti-aim pattern state
local aa_patterns          = setmetatable({}, { __mode = "k" })

-- NN-related per-entity prediction cache (short term)
local prediction_cache     = setmetatable({}, { __mode = "k" })

-- Last cleanup time
local last_cleanup_time    = 0

-- Prediction cache duration
local PREDICTION_CACHE_SEC = 0.03

-- Long-term behavior profiles
local behavior_profiles = {}

-- File names for persistence
local BEHAVIOR_PROFILE_FILE = "resolver_behavior_profiles.json"
local EXPERIENCE_LOG_FILE   = "resolver_experiences.json"

-- Local in-memory experience cache for pretraining
local experience_log = {}

-- Limit how many experiences we keep on disk (to avoid bloat)
local MAX_EXPERIENCES_ON_DISK = 8000

-- Per-entity lag compensation / choke state
local lagcomp_state = setmetatable({}, { __mode = "k" })

-- Live dashboard state
local last_nn_conf   = 0
local last_pattern   = "none"
local last_lag_status = "unknown"
local last_desync    = 0
local last_source    = "none"

-- Tuning constants for lagcomp heuristic
local LAGCOMP_MAX_CHOKE_TICKS   = 14     -- typical max choke
local LAGCOMP_MIN_REAL_DELTA    = 0.010  -- min simtime delta to consider "real update"
local LAGCOMP_BIG_DELTA         = 0.05   -- big jump = likely real shift / break
local LAGCOMP_HISTORY_DECAY     = 0.9    -- smoothing for confidence

----------------------------------------------------------------
-- UI Elements / Frost Resolver UI
----------------------------------------------------------------

-- Header
ui.new_label("RAGE", "Other", "\aBBC0F3FF" .. "❄  Frost Resolver V2  ❄" .. "\aFFFFFFFF")
ui.new_label("RAGE", "Other", "\aC8C8C8FFAdaptive Neural Anti‑Aim Resolver")


----------------------------------------------------------------
-- Resolver Settings
----------------------------------------------------------------


resolver_master = ui.new_checkbox("RAGE", "Other", "Enable Frost Resolver")
resolver_debug  = ui.new_checkbox("RAGE", "Other", "Resolver Debug Overlay")

hitlog_level = ui.new_combobox(
    "RAGE", "Other",
    "Hit/Miss Log Level",
    { "-", "Basic", "Detailed" }
)

local resolver_mode = ui.new_combobox("RAGE", "Other", "Resolver Mode", {
    "Balanced",
    "Aggressive",
    "Safe",
    "Experimental NN",
    "Legacy"
})



----------------------------------------------------------------
-- Neural Network
----------------------------------------------------------------



local nn_enable = ui.new_checkbox("RAGE", "Other", "Enable Neural Network")

local nn_conf_bias = ui.new_slider("RAGE", "Other", "NN Confidence Bias", 0, 100, 50)
local nn_blend_strength = ui.new_slider("RAGE", "Other", "NN Blend Strength", 0, 100, 60)
local nn_train_during_match = ui.new_checkbox("RAGE", "Other", "Train During Match")


----------------------------------------------------------------
-- Pattern Detection
----------------------------------------------------------------


local static_sensitivity = ui.new_slider("RAGE", "Other", "Static Sensitivity", 1, 50, 32)
local jitter_sensitivity = ui.new_slider("RAGE", "Other", "Jitter Sensitivity", 1, 50, 5)
local flick_sensitivity  = ui.new_slider("RAGE", "Other", "Flick Sensitivity", 1, 100, 80)
local behavior_profiles_enable = ui.new_checkbox("RAGE", "Other", "Enable Behavior Profiles")



----------------------------------------------------------------
-- Debug & Dashboard
----------------------------------------------------------------



debug_options = ui.new_multiselect(
    "RAGE", "Other",
    "Resolver Debug Info",
    {
        "Eye Angles",
        "Desync",
        "Movement",
        "Anim Layers",
        "NN Confidence",
        "NN Predictions",
        "Hit/Miss Stats",
        "Anti-Aim Pattern"
    }
)

local dashboard_toggle = ui.new_checkbox("RAGE", "Other", "Show Frost Dashboard")



----------------------------------------------------------------
-- Advanced Tweaks
----------------------------------------------------------------



local tweak_desync_shape   = ui.new_slider("RAGE", "Other", "Desync Shaping Strength", 0, 100, 50)
local tweak_lagcomp_trust  = ui.new_slider("RAGE", "Other", "Lagcomp Trust Factor", 0, 100, 45)
local tweak_pattern_weight = ui.new_slider("RAGE", "Other", "Pattern Override Weight", 0, 100, 70)
local tweak_nn_weight      = ui.new_slider("RAGE", "Other", "NN Override Weight", 0, 100, 60)


----------------------------------------------------------------
-- Data Management
----------------------------------------------------------------

local clear_cache_button = ui.new_button("RAGE", "Other", "Clear Resolver Cache", function()
    if writefile then
        writefile(BEHAVIOR_PROFILE_FILE, "{}")
        writefile(EXPERIENCE_LOG_FILE, "[]")
    end
    behavior_profiles = {}
    experience_log = {}
    client.log("[FrostReso] Cleared behavior profiles and experience cache.")
end)

frost_divider()
ui.new_label("RAGE", "Other", "\aC8C8C8FFFrost Resolver V2 — Neural Anti‑Aim Engine")



----------------------------------------------------------------
-- Constants & Enums
----------------------------------------------------------------

-- Movement flags (CS:GO m_fFlags)
local FL_ONGROUND = 1
local FL_DUCKING  = 2
-- Add more if needed later (e.g. FL_INWATER, FL_ONTRAIN)

-- Animation layer indices (0-based in C/FFI, we will pass 0..13)
-- These are used for interpretation, but we will be careful and nil-check.
local LAYER_INDEXES = {
    AIM_MATRIX                = 0,  -- un-com
    WEAPON_ACTION             = 1,
    JUMP_OR_FALL              = 4,
    MOVEMENT                  = 6,
    ALIVELOOP                 = 8,
    LEAN                      = 3,
    ADJUST                    = 12
}

----------------------------------------------------------------
-- Generic Utility Functions
----------------------------------------------------------------

local function clamp(v, mn, mx)
    if v < mn then return mn end
    if v > mx then return mx end
    return v
end

local function normalize_yaw(yaw)
    while yaw > 180 do yaw = yaw - 360 end
    while yaw < -180 do yaw = yaw + 360 end
    return yaw
end

local function angle_diff(a, b)
    local d = normalize_yaw(a - b)
    return d
end

local function vec_len2d(x, y)
    return sqrt((x or 0) * (x or 0) + (y or 0) * (y or 0))
end

local function log_hitmiss(level, fmt, ...)
    local selected = ui.get(hitlog_level)

    if selected == "-" then
        return
    end

    if selected == "Basic" and level == "detailed" then
        return
    end

    local ok, msg = pcall(string.format, fmt, ...)
    if not ok or not msg then
        msg = fmt
    end

    client.log("[FrostReso HM] " .. msg)
end

----------------------------------------------------------------
-- Entity / Player Helpers
----------------------------------------------------------------

local function is_valid_enemy(ent)
    if not ent or not entity.is_alive(ent) then return false end
    if entity.get_classname(ent) ~= "CCSPlayer" then return false end

    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then return false end

    local team_lp  = entity.get_prop(lp, "m_iTeamNum")
    local team_ent = entity.get_prop(ent, "m_iTeamNum")
    if not team_lp or not team_ent or team_lp == team_ent then
        return false
    end

    return true
end

----------------------------------------------------------------
-- Safe Animstate / Layer Access
----------------------------------------------------------------

local function get_animstate(ent)
    local ent_ptr = ent_c.get_client_entity(ent)
    if ent_ptr == nil or ent_ptr == ffi.NULL then
        return nil
    end

    local state_ptr = ffi.cast("animation_state_t*", ffi.cast("char*", ent_ptr) + ANIMSTATE_OFFSET)
    if state_ptr == nil or state_ptr == ffi.NULL then
        return nil
    end

    return state_ptr
end

local function get_animlayer(ent, index)
    -- index is expected to be 0-based (0..13), as in C array
    local ent_ptr = ent_c.get_client_entity(ent)
    if ent_ptr == nil or ent_ptr == ffi.NULL then
        return nil
    end

    local layers_base = ffi.cast("animation_layer_t*", ffi.cast("char*", ent_ptr) + ANIMLAYERS_OFFSET)
    if layers_base == nil or layers_base == ffi.NULL then
        return nil
    end

    -- LuaJIT FFI arrays use 0-based indexing when accessed like ptr[index]
    local layer = layers_base[index]
    return layer
end

----------------------------------------------------------------
-- Internal Helpers
----------------------------------------------------------------

local function get_velocity(ent)
    local vx, vy, vz = entity.get_prop(ent, "m_vecVelocity")
    return vx or 0, vy or 0, vz or 0
end

local function get_eye_angles(ent)
    local pitch = entity.get_prop(ent, "m_angEyeAngles[0]") or 0
    local yaw   = entity.get_prop(ent, "m_angEyeAngles[1]") or 0
    return pitch, yaw
end

local function get_flags(ent)
    return entity.get_prop(ent, "m_fFlags") or 0
end

local function get_duck_amount(ent)
    return entity.get_prop(ent, "m_flDuckAmount") or 0
end

local function get_simtime(ent)
    return entity.get_prop(ent, "m_flSimulationTime") or 0
end

local function get_tickcount()
    return globals.tickcount and globals.tickcount() or floor(globals.curtime() / globals.tickinterval())
end

local function init_lagcomp_state(ent)
    local st = lagcomp_state[ent]
    if not st then
        st = {
            last_simtime      = 0,
            last_tick         = 0,
            choke_ticks       = 0,
            last_delta        = 0,
            real_update_conf  = 0,  -- 0..1, confidence this is a "real" update
            status            = "unknown" -- "choking", "real", "idle"
        }
        lagcomp_state[ent] = st
    end
    return st
end

local function update_lagcomp_predictor(ent)
    local st = init_lagcomp_state(ent)
    local simtime = get_simtime(ent)
    local tick = get_tickcount()

    if st.last_tick == 0 then
        st.last_tick = tick
        st.last_simtime = simtime
        st.status = "idle"
        st.real_update_conf = 0
        return st
    end

    local tick_delta = tick - st.last_tick
    if tick_delta <= 0 then
        return st
    end

    local sim_delta = simtime - st.last_simtime

    -- Choking: simtime not advancing while ticks pass
    if sim_delta <= 0 then
        st.choke_ticks = st.choke_ticks + tick_delta
        st.status = "choking"
        st.real_update_conf = st.real_update_conf * LAGCOMP_HISTORY_DECAY
    else
        -- Simtime advanced: some sort of update happened
        st.last_delta = sim_delta

        -- Heuristic: big simtime jump or long choke before update = likely "real" update
        local is_big_jump = sim_delta >= LAGCOMP_BIG_DELTA
        local had_choke   = st.choke_ticks >= 2

        local instant_conf = 0
        if is_big_jump and had_choke then
            instant_conf = 1.0
        elseif had_choke and sim_delta >= LAGCOMP_MIN_REAL_DELTA then
            instant_conf = 0.8
        elseif sim_delta >= LAGCOMP_MIN_REAL_DELTA then
            instant_conf = 0.5
        else
            instant_conf = 0.2
        end

        st.real_update_conf = st.real_update_conf * LAGCOMP_HISTORY_DECAY + instant_conf * (1 - LAGCOMP_HISTORY_DECAY)

        if st.real_update_conf > 0.45 then
            st.status = "real"
        else
            st.status = "updating"
        end

        -- Reset choke
        st.choke_ticks = 0
    end

    st.last_tick = tick
    st.last_simtime = simtime

    -- Hard cap choke to avoid overflow
    if st.choke_ticks > LAGCOMP_MAX_CHOKE_TICKS then
        st.choke_ticks = LAGCOMP_MAX_CHOKE_TICKS
    end

    return st
end

local function get_lagcomp_info(ent)
    local st = lagcomp_state[ent]
    if not st then
        return {
            status = "unknown",
            choke_ticks = 0,
            real_conf = 0,
            last_delta = 0
        }
    end

    return {
        status      = st.status or "unknown",
        choke_ticks = st.choke_ticks or 0,
        real_conf   = st.real_update_conf or 0,
        last_delta  = st.last_delta or 0
    }
end

----------------------------------------------------------------
-- Short-term Behavior Tracking Helpers
----------------------------------------------------------------

local function ensure_short_term_fields(state)
    state.yaw_delta_sum   = state.yaw_delta_sum   or 0
    state.yaw_delta_count = state.yaw_delta_count or 0
    state.desync_sum      = state.desync_sum      or 0
    state.desync_count    = state.desync_count    or 0
    state.jitter_events   = state.jitter_events   or 0
    state.last_pattern    = state.last_pattern    or "none"
end


local function init_entity_state(ent)
    local state = resolver_states[ent]

    if not state then
        state = {}
        resolver_states[ent] = state
    end

    ensure_short_term_fields(state)
    return state
end



local function update_short_term_stats(ent, yaw_delta, desync, pattern)
    local state = init_entity_state(ent)
    ensure_short_term_fields(state)


    -- Track average yaw_delta
    state.yaw_delta_sum = state.yaw_delta_sum + yaw_delta
    state.yaw_delta_count = state.yaw_delta_count + 1

    -- Track average desync magnitude
    state.desync_sum = state.desync_sum + abs(desync)
    state.desync_count = state.desync_count + 1

    -- Track jitter events
    if abs(yaw_delta) > 35 then
        state.jitter_events = state.jitter_events + 1
    end

    -- Remember last pattern
    if pattern and pattern.pattern then
        state.last_pattern = pattern.pattern
    end
end

local function get_short_term_summary(ent)
    local state = resolver_states[ent]
    if state then ensure_short_term_fields(state) end
    if not state then
        return {
            avg_yaw_delta  = 0,
            avg_desync     = 0,
            jitter_density = 0,
            last_pattern   = "none"
        }
    end

    local avg_yaw_delta = 0
    if state.yaw_delta_count > 0 then
        avg_yaw_delta = state.yaw_delta_sum / state.yaw_delta_count
    end

    local avg_desync = 0
    if state.desync_count > 0 then
        avg_desync = state.desync_sum / state.desync_count
    end

    local jitter_density = 0
    if state.yaw_delta_count > 0 then
        jitter_density = state.jitter_events / state.yaw_delta_count
    end

    return {
        avg_yaw_delta  = avg_yaw_delta,
        avg_desync     = avg_desync,
        jitter_density = jitter_density,
        last_pattern   = state.last_pattern or "none"
    }
end

----------------------------------------------------------------
-- Animation Layer Sampling
----------------------------------------------------------------

local function sample_layer(ent, idx)
    local layer = get_animlayer(ent, idx)
    if not layer then
        return {
            weight = 0,
            cycle = 0,
            playback = 0,
            sequence = 0
        }
    end

    return {
        weight    = layer.m_flWeight or 0,
        cycle     = layer.m_flCycle or 0,
        playback  = layer.m_flPlaybackRate or 0,
        sequence  = layer.m_nSequence or 0
    }
end

----------------------------------------------------------------
-- Feature Extraction (c24)
----------------------------------------------------------------

local function extract_features(ent)
    local state = resolver_states[ent]
    if not state then
        state = {}
        resolver_states[ent] = state
    end

    ------------------------------------------------------------
    -- Basic movement
    ------------------------------------------------------------
    local vx, vy, vz = get_velocity(ent)
    local speed2d = vec_len2d(vx, vy)
    local flags   = get_flags(ent)
    local duck    = get_duck_amount(ent)

    local on_ground = band(flags, FL_ONGROUND) ~= 0
    local ducking   = band(flags, FL_DUCKING) ~= 0

    ------------------------------------------------------------
    -- Eye angles
    ------------------------------------------------------------
    local pitch, yaw = get_eye_angles(ent)

    ------------------------------------------------------------
    -- Animstate
    ------------------------------------------------------------
    local anim = get_animstate(ent)
    local anim_speed2d = 0
    local anim_feet_yaw = 0
    local anim_goal_feet_yaw = 0

    if anim then
        anim_speed2d       = anim.m_flSpeed2D or 0
        anim_feet_yaw      = anim.m_flEyeYaw or 0
        anim_goal_feet_yaw = anim.m_flGoalFeetYaw or 0
    end

    ------------------------------------------------------------
    -- Animation layers
    ------------------------------------------------------------
    local layer_move = sample_layer(ent, LAYER_INDEXES.MOVEMENT)
    local layer_lean = sample_layer(ent, LAYER_INDEXES.LEAN)
    local layer_adj  = sample_layer(ent, LAYER_INDEXES.ADJUST)

    ------------------------------------------------------------
    -- Desync estimation
    ------------------------------------------------------------
    local body_yaw_param = entity.get_prop(ent, "m_flPoseParameter", 11) or 0
    local body_yaw = (body_yaw_param * 116) - 29

    local desync = normalize_yaw(yaw - body_yaw)
    desync = clamp(desync, -29, 29)

    ------------------------------------------------------------
    -- Movement history (pat rec)
    ------------------------------------------------------------
    state.last_yaw = state.last_yaw or yaw
    state.yaw_delta = normalize_yaw(yaw - state.last_yaw)
    state.last_yaw = yaw

    state.last_speed = state.last_speed or speed2d
    state.speed_delta = speed2d - state.last_speed
    state.last_speed = speed2d

    ------------------------------------------------------------
    -- Build feature vector (F.P.24)
    ------------------------------------------------------------
    local features = {
        -- 1–4: movement
        speed2d / 300,                 -- normalized
        clamp(vx / 300, -1, 1),
        clamp(vy / 300, -1, 1),
        duck,

        -- 5–8: flags & state
        on_ground and 1 or 0,
        ducking and 1 or 0,
        clamp(vz / 300, -1, 1),
        0, -- (strafe dir, etc.)

        -- 9–12: eye angles
        (yaw + 180) / 360,
        (pitch + 89) / 178,
        (state.yaw_delta + 180) / 360,
        (state.speed_delta + 300) / 600,

        -- 13–16: animstate
        clamp(anim_speed2d / 300, 0, 1),
        (anim_feet_yaw + 180) / 360,
        (anim_goal_feet_yaw + 180) / 360,
        0, -- reserved

        -- 17–20: movement layer
        layer_move.weight,
        layer_move.playback,
        layer_move.cycle,
        layer_move.sequence / 64,

        -- 21–24: lean/adjust layers
        layer_lean.weight,
        layer_lean.playback,
        layer_adj.weight,
        (desync + 29) / 58
    }

    return features, desync, yaw, pitch
end

----------------------------------------------------------------
-- Anti-Aim Pattern Detection
----------------------------------------------------------------

local function detect_patterns(ent, features, desync, yaw)
    local pat = aa_patterns[ent]
    if not pat then
        pat = {
            jitter_count = 0,
            static_ticks = 0,
            last_yaw = yaw,
            last_desync = desync,
            last_update = globals.curtime(),
            pattern = "none",
            confidence = 0
        }
        aa_patterns[ent] = pat
    end

    local yaw_delta    = normalize_yaw(yaw - pat.last_yaw)
    local desync_delta = desync - pat.last_desync

    pat.last_yaw    = yaw
    pat.last_desync = desync

    ------------------------------------------------------------
    -- Jitter detection: require more consecutive large swings
    ------------------------------------------------------------
    if abs(yaw_delta) > 35 then
        pat.jitter_count = pat.jitter_count + 1
    else
        pat.jitter_count = max(0, pat.jitter_count - 1)
    end

    if pat.jitter_count >= 5 then
        pat.pattern = "jitter"
        pat.confidence = clamp(pat.confidence + 0.08, 0, 1)
    end

    ------------------------------------------------------------
    -- Static AA detection: require many small deltas in a row
    ------------------------------------------------------------
    if abs(yaw_delta) < 1 and abs(desync_delta) < 1 then
        pat.static_ticks = (pat.static_ticks or 0) + 1
    else
        pat.static_ticks = max(0, (pat.static_ticks or 0) - 2)
    end

    if pat.static_ticks >= 32 then
        pat.pattern = "static"
        pat.confidence = clamp(pat.confidence + 0.03, 0, 1)
    end


    ------------------------------------------------------------
    -- Rapid manipulation (fake flicks)
    ------------------------------------------------------------
    if abs(yaw_delta) > 80 then
        pat.pattern = "flick"
        pat.confidence = clamp(pat.confidence + 0.10, 0, 1)
    end

    ------------------------------------------------------------
    -- Default decay when not obviously matching anything
    ------------------------------------------------------------
    if pat.pattern == "none" then
        pat.confidence = clamp(pat.confidence - 0.03, 0, 1)
    end

    -- Always update short-term stats (was previously only on "none" path)
    update_short_term_stats(ent, yaw_delta, desync, pat)

    return pat
end


----------------------------------------------------------------
-- Behavior Signature n Profiles
----------------------------------------------------------------

local function quantize(value, step, min_v, max_v)
    value = clamp(value, min_v, max_v)
    return floor(value / step + 0.5) * step
end

local function get_behavior_signature(ent, pat)
    local summary = get_short_term_summary(ent)

    -- Quantize key aspects into a coarse "style" bucket
    local q_yaw_delta  = quantize(summary.avg_yaw_delta, 10, -180, 180)
    local q_desync     = quantize(summary.avg_desync, 5, 0, 29)
    local q_jitter     = quantize(summary.jitter_density, 0.1, 0, 1)
    local pattern_name = (pat and pat.pattern) or summary.last_pattern or "none"

    -- Signature key (style-based, not identity-based)
    local key = string.format(
        "%s|yd=%.0f|ds=%.0f|jit=%.1f",
        pattern_name, q_yaw_delta, q_desync, q_jitter
    )

    return key, summary
end

local function update_behavior_profile(ent, pat)
    if not pat or pat.pattern == "none" or pat.confidence < 0.7 then
        return
    end

    local key, summary = get_behavior_signature(ent, pat)
    if not key then return end

    local prof = behavior_profiles[key]
    if not prof then
        prof = {
            count         = 0,
            avg_desync    = 0,
            avg_yaw_delta = 0,
            jitter_density = 0,
            pattern       = pat.pattern
        }
        behavior_profiles[key] = prof
    end

    prof.count = prof.count + 1
    local w = prof.count

    prof.avg_desync = ((prof.avg_desync * (w - 1)) + summary.avg_desync) / w
    prof.avg_yaw_delta = ((prof.avg_yaw_delta * (w - 1)) + summary.avg_yaw_delta) / w
    prof.jitter_density = ((prof.jitter_density * (w - 1)) + summary.jitter_density) / w
end

local function get_behavior_profile_features(ent, pat)
    local key = select(1, get_behavior_signature(ent, pat))
    if not key then
        return 0, 0, 0
    end

    local prof = behavior_profiles[key]
    if not prof or prof.count < 10 then
        -- Not enough evidence, don't bias too much
        return 0, 0, 0
    end

    -- Return normalized hints:
    -- 1) avg_desync (0..1)
    -- 2) yaw_delta bias (-1..1)
    -- 3) jitter density (0..1)
    local desync_hint = clamp(prof.avg_desync / 29, 0, 1)
    local yaw_hint    = clamp(prof.avg_yaw_delta / 180, -1, 1)
    local jitter_hint = clamp(prof.jitter_density, 0, 1)

    return desync_hint, yaw_hint, jitter_hint
end

----------------------------------------------------------------
-- Public API
----------------------------------------------------------------

local function get_entity_features(ent)
    local features, desync, yaw, pitch = extract_features(ent)
    local pattern = detect_patterns(ent, features, desync, yaw)
    return features, desync, yaw, pitch, pattern
end

resolver_states.get_entity_features = get_entity_features

----------------------------------------------------------------
-- Prediction Wrapper
----------------------------------------------------------------

local function nn_predict(ent, features)
    if not features then return nil, nil end

    -- Short-term cache to avoid redundant NN calls
    local cache = prediction_cache[ent]
    local now = globals.curtime()

    if cache and (now - cache.time) < PREDICTION_CACHE_SEC then
        return cache.pred, cache.conf
    end

    -- Call enhanced_nn.predict
    local ok, pred, hidden, masks = pcall(enhanced_nn.predict, features, false)
    if not ok or not pred then
        return nil, nil
    end

    -- Convert NN outputs to meaningful values
    -- pred[1] = normalized yaw (0..1)
    -- pred[2] = normalized desync (0..1)
    -- pred[3] = normalized head bias (0..1) -> [-1..1]

    local resolved_yaw    = (pred[1] * 360) - 180
    local resolved_desync = (pred[2] * 58) - 29


    local head_bias = 0
    if pred[3] ~= nil then
        -- Map 0..1 -> -1..1
        head_bias = clamp((pred[3] * 2) - 1, -1, 1)
    end

    -- Softer, multi-output confidence:
    -- - yaw away from center
    -- - desync away from center
    -- - small floor so it's never 0 while learning
    local yaw_margin    = clamp(abs(pred[1] - 0.5) * 2, 0, 1)
    local desync_margin = clamp(abs(pred[2] - 0.5) * 2, 0, 1)

    local confidence = 0.2 + yaw_margin * 0.5 + desync_margin * 0.3
    confidence = clamp(confidence, 0, 1)

    -- Cache
    prediction_cache[ent] = {
        pred = {
            yaw       = resolved_yaw,
            desync    = resolved_desync,
            head_bias = head_bias
        },
        conf = confidence,
        time = now
    }

    return prediction_cache[ent].pred, confidence
end


----------------------------------------------------------------
-- Experience Replay: Add Experience
----------------------------------------------------------------

----------------------------------------------------------------
-- Experience Replay: Add Experience
----------------------------------------------------------------

local function add_experience(ent, features, actual_desync, hit_success, hitgroup)
    if not features then return end

    -- Head bias target:
    -- If we hit head, encourage bias in the current desync direction.
    local head_bias_target = 0
    if hit_success and hitgroup == 1 then -- HITGROUP_HEAD
        local sign = actual_desync >= 0 and 1 or -1
        head_bias_target = sign
    end

    -- Convert actual desync to normalized targets
    local target = {
        0.5,                              -- yaw target (placeholder / not trained)
        (actual_desync + 29) / 58,        -- correct desync target
        (head_bias_target + 1) / 2
    }


    local reward = hit_success and 1 or -1

    -- Feed into NN replay system
    enhanced_nn.add_experience(features, target, reward, hit_success)

    -- Also store a lightweight copy for cross-match pretraining
    experience_log[#experience_log + 1] = {
        features    = features,
        target      = target,
        reward      = reward,
        hit_success = hit_success,
        hitgroup    = hitgroup
    }
end



----------------------------------------------------------------
-- Training Scheduler
----------------------------------------------------------------

local TRAIN_INTERVAL = 0.15
local last_train_time = 0

local function train_nn()
    if nn_train_during_match and not ui.get(nn_train_during_match) then
        return
    end

    local now = globals.curtime()
    if now - last_train_time < TRAIN_INTERVAL then
        return
    end
    last_train_time = now

    local batch = enhanced_nn.sample_batch()
    if batch then
        enhanced_nn.train(batch)
    end

    enhanced_nn.save()
end


----------------------------------------------------------------
-- Hit/Miss Tracking
----------------------------------------------------------------

local function register_hit(ent, features, desync, hitgroup)
    hit_miss_data[ent] = hit_miss_data[ent] or { hits = 0, misses = 0 }
    hit_miss_data[ent].hits = hit_miss_data[ent].hits + 1

    add_experience(ent, features, desync, true, hitgroup)

    -- Logging
    local res = resolver_states[ent] and resolver_states[ent].resolved or nil
    local pat = aa_patterns[ent]
    local lc  = get_lagcomp_info(ent)

    -- Basic log: just outcome + a few key numbers
    log_hitmiss(
        "basic",
        "HIT ent=%d hg=%d desync=%.1f src=%s nn_conf=%.2f",
        ent,
        hitgroup or -1,
        desync or 0,
        res and res.source or "unknown",
        res and (res.nn_conf or 0) or 0
    )

    -- Detailed log: full resolver context at hit time
    log_hitmiss(
        "detailed",
        "HIT ent=%d name='%s' hg=%d desync=%.1f resolved_desync=%.1f yaw=%.1f src=%s nn_conf=%.2f head_bias=%.2f pattern=%s pat_conf=%.2f lag_status=%s lag_choke=%d lag_conf=%.2f",
        ent,
        entity.get_player_name(ent) or "unknown",
        hitgroup or -1,
        desync or 0,
        res and (res.desync or 0) or 0,
        res and (res.yaw or 0) or 0,
        res and res.source or "unknown",
        res and (res.nn_conf or 0) or 0,
        res and (res.head_bias or 0) or 0,
        res and (res.pattern or "none") or "none",
        pat and (pat.confidence or 0) or 0,
        lc.status or "unknown",
        lc.choke_ticks or 0,
        lc.real_conf or 0
    )
end


local function register_miss(ent, features, desync)
    hit_miss_data[ent] = hit_miss_data[ent] or { hits = 0, misses = 0 }
    hit_miss_data[ent].misses = hit_miss_data[ent].misses + 1

    add_experience(ent, features, desync, false, nil)

    -- Logging
    local res = resolver_states[ent] and resolver_states[ent].resolved or nil
    local pat = aa_patterns[ent]
    local lc  = get_lagcomp_info(ent)

    -- Basic log: miss with a few key numbers
    log_hitmiss(
        "basic",
        "MISS ent=%d desync=%.1f src=%s nn_conf=%.2f",
        ent,
        desync or 0,
        res and res.source or "unknown",
        res and (res.nn_conf or 0) or 0
    )

    -- Detailed log: full resolver context at miss time
    log_hitmiss(
        "detailed",
        "MISS ent=%d name='%s' desync=%.1f resolved_desync=%.1f yaw=%.1f src=%s nn_conf=%.2f head_bias=%.2f pattern=%s pat_conf=%.2f lag_status=%s lag_choke=%d lag_conf=%.2f",
        ent,
        entity.get_player_name(ent) or "unknown",
        desync or 0,
        res and (res.desync or 0) or 0,
        res and (res.yaw or 0) or 0,
        res and res.source or "unknown",
        res and (res.nn_conf or 0) or 0,
        res and (res.head_bias or 0) or 0,
        res and (res.pattern or "none") or "none",
        pat and (pat.confidence or 0) or 0,
        lc.status or "unknown",
        lc.choke_ticks or 0,
        lc.real_conf or 0
    )
end



----------------------------------------------------------------
-- GameSense Callbacks: Single Clean Versions
----------------------------------------------------------------

-- Weapon Fire: record shot state
local last_shot = {}

client.set_event_callback("weapon_fire", function(e)
    if not ui.get(resolver_master) then return end

    local shooter = client.userid_to_entindex(e.userid)
    local lp = entity.get_local_player()
    if shooter ~= lp then return end

    -- Mark shot time
    last_shot.time = globals.curtime()
    last_shot.target = nil
end)

-- Player Hurt: positive reward
client.set_event_callback("player_hurt", function(e)
    if not ui.get(resolver_master) then return end

    local attacker = client.userid_to_entindex(e.attacker)
    local victim   = client.userid_to_entindex(e.userid)
    local lp       = entity.get_local_player()

    if attacker ~= lp then return end
    if not is_valid_enemy(victim) then return end

    -- Extract features at hit moment
    local features, desync = resolver_states.get_entity_features(victim)
    if not features then return end

    register_hit(victim, features, desync, e.hitgroup)
end)

-- Shot Miss
client.set_event_callback("aim_miss", function(e)
    if not ui.get(resolver_master) then return end

    local ent = e.target
    if not ent or not is_valid_enemy(ent) then return end

    local features, desync = resolver_states.get_entity_features(ent)
    if not features then return end

    register_miss(ent, features, desync)
end)

----------------------------------------------------------------
-- Public API
----------------------------------------------------------------

local function get_nn_prediction(ent, features)
    return nn_predict(ent, features)
end

resolver_states.get_nn_prediction = get_nn_prediction
resolver_states.train_nn = train_nn

----------------------------------------------------------------
-- Confidence Weighting
----------------------------------------------------------------

local function blend(a, b, t)
    return a * (1 - t) + b * t
end

local function shape_desync(desync)
    local sign = desync >= 0 and 1 or -1
    local mag  = abs(desync)

    local strength = tweak_desync_shape and ui.get(tweak_desync_shape) or 50
    strength = strength / 100

    if strength <= 0.01 then
        return desync
    end

    local base     = 18 / (mag + 10)
    local aggressive = 10 / (mag + 5)
    local factor   = base * (1 - strength) + aggressive * strength

    local compressed = mag * factor
    return sign * compressed
end


----------------------------------------------------------------
-- Strategy Selection
----------------------------------------------------------------

local function choose_strategy(ent, nn_pred, nn_conf, pattern, desync)
    local lc = get_lagcomp_info(ent)

    -- Behavior-based hints
    local desync_hint, yaw_hint, jitter_hint = get_behavior_profile_features(ent, pattern)

    nn_conf = nn_conf or 0
    local lc_conf = lc and lc.real_conf or 0

    ------------------------------------------------------------
    -- Read UI tweaks and mode
    ------------------------------------------------------------
    local mode = resolver_mode and ui.get(resolver_mode) or "Balanced"

    local lag_trust = tweak_lagcomp_trust and ui.get(tweak_lagcomp_trust) or 45
    lag_trust = lag_trust / 50  -- 0.0–2.0 scale

    local pattern_weight = tweak_pattern_weight and ui.get(tweak_pattern_weight) or 70
    pattern_weight = pattern_weight / 100 -- 0.0–1.0

    local nn_weight = tweak_nn_weight and ui.get(tweak_nn_weight) or 60
    nn_weight = nn_weight / 100 -- 0.0–1.0

    local conf_bias = nn_conf_bias and ui.get(nn_conf_bias) or 50
    conf_bias = (conf_bias - 50) / 100  -- -0.5..+0.5

    local blend_strength = nn_blend_strength and ui.get(nn_blend_strength) or 60
    blend_strength = blend_strength / 100 -- used in blend branch

    local nn_on = (not nn_enable) or ui.get(nn_enable) -- if checkbox missing, assume on

    -- Apply lagcomp trust
    lc_conf = clamp(lc_conf * lag_trust, 0, 1)

    -- Apply NN confidence bias
    nn_conf = clamp(nn_conf + conf_bias, 0, 1)

    ------------------------------------------------------------
    -- Mode presets (threshold tuning)
    ------------------------------------------------------------
    local nn_strong = 0.7
    local nn_ok     = 0.45
    local pattern_min_conf = 0.7
    local nn_blend_min = 0.25

    if mode == "Aggressive" then
        nn_strong = 0.55
        nn_ok     = 0.30
        pattern_min_conf = 0.6
        nn_blend_min = 0.15
    elseif mode == "Safe" then
        nn_strong = 0.8
        nn_ok     = 0.6
        pattern_min_conf = 0.75
        nn_blend_min = 0.35
    elseif mode == "Experimental NN" then
        nn_strong = 0.4
        nn_ok     = 0.2
        pattern_min_conf = 0.8
        nn_blend_min = 0.1
    elseif mode == "Legacy" then
        nn_strong = 0.85
        nn_ok     = 0.6
        pattern_min_conf = 0.65
        nn_blend_min = 0.3
    end

    ------------------------------------------------------------
    -- High / OK confidence NN: let it lead, but still shape
    ------------------------------------------------------------
    local lc_good = lc_conf > 0.4
    if nn_on and nn_pred and (nn_conf > nn_strong or (nn_conf > nn_ok and lc_good)) then
        local desync_res = nn_pred.desync

        -- Style-based prior on desync magnitude
        if desync_hint ~= 0 then
            local sign = desync_res >= 0 and 1 or -1
            local hinted = desync_hint * 29 * sign
            desync_res = blend(desync_res, hinted, 0.2 * nn_weight)
        end

        -- Head-bias: slight nudge
        if nn_pred.head_bias then
            local head_nudge = nn_pred.head_bias * 6 * nn_weight
            desync_res = desync_res + head_nudge
        end

        -- Shape and clamp final NN desync
        desync_res = clamp(shape_desync(desync_res), -29, 29)

        return {
            yaw    = nn_pred.yaw,
            desync = desync_res,
            source = "nn_lead"
        }
    end

    ----------------------------------------------------------------
    -- Pattern-based overrides: only when NN is weak and lagcomp is OK
    ----------------------------------------------------------------
    local can_use_pattern = (not nn_pred) or nn_conf < (0.35 + (1 - nn_weight) * 0.2)
    if pattern and pattern.confidence > pattern_min_conf and can_use_pattern and lc_conf > 0.3 then
        if pattern.pattern == "jitter" then
            local ds = -desync
            ds = clamp(shape_desync(ds * pattern_weight), -29, 29)
            return {
                yaw    = nn_pred and nn_pred.yaw or 0,
                desync = ds,
                source = "pattern_jitter"
            }
        end

        if pattern.pattern == "static" then
            local ds = desync
            if desync_hint ~= 0 then
                local sign = ds >= 0 and 1 or -1
                local hinted = desync_hint * 29 * sign
                ds = blend(ds, hinted, 0.3 * pattern_weight)
            end

            ds = clamp(shape_desync(ds), -29, 29)

            return {
                yaw    = nn_pred and nn_pred.yaw or 0,
                desync = ds,
                source = "pattern_static"
            }
        end

        if pattern.pattern == "flick" then
            local ds = desync * (1.0 + 0.5 * pattern_weight)
            ds = clamp(shape_desync(ds), -29, 29)
            return {
                yaw    = nn_pred and nn_pred.yaw or 0,
                desync = ds,
                source = "pattern_flick"
            }
        end
    end

    ----------------------------------------------------------------
    -- Medium confidence NN - blend with raw desync
    ----------------------------------------------------------------
    if nn_on and nn_pred and nn_conf > nn_blend_min then
        local ds_nn = clamp(nn_pred.desync, -29, 29)
        local ds = blend(desync, ds_nn, nn_conf * blend_strength * nn_weight)
        ds = clamp(shape_desync(ds), -29, 29)
        return {
            yaw    = nn_pred.yaw,
            desync = ds,
            source = "nn_blend"
        }
    end

    ----------------------------------------------------------------
    -- Low confidence fallback
    ----------------------------------------------------------------
    local ds = clamp(desync, -29, 29)
    ds = clamp(shape_desync(ds), -29, 29)

    return {
        yaw    = 0,
        desync = ds,
        source = "fallback"
    }
end


----------------------------------------------------------------
-- Final Resolver Application
----------------------------------------------------------------

local function resolve_entity(ent)
    if not is_valid_enemy(ent) then return end
    -- Update lagcomp / choke prediction for this entity
    local laginfo = update_lagcomp_predictor(ent)

    -- Extract features
    local features, desync, yaw, pitch, pattern =
        resolver_states.get_entity_features(ent)

    if not features then return end

    -- NN prediction
    local nn_pred, nn_conf =
        resolver_states.get_nn_prediction(ent, features)

    -- Choose strategy
    local result = choose_strategy(ent, nn_pred, nn_conf, pattern, desync)
    if not result then return end

    -- Update long-term behavior profile when pattern is stable
    if pattern and pattern.confidence and pattern.confidence > 0.75 then
        update_behavior_profile(ent, pattern)
    end


    -- Apply resolver to GameSense
    plist.set(ent, "Force body yaw", true)
    plist.set(ent, "Force body yaw value", result.desync)

    -- Store for debug
    local lc = get_lagcomp_info(ent)

    resolver_states[ent].resolved = {
        yaw       = result.yaw,
        desync    = result.desync,
        source    = result.source,
        nn_conf   = nn_conf or 0,
        pattern   = pattern and pattern.pattern or "none",
        head_bias = nn_pred and nn_pred.head_bias or 0,
        lag_status = lc.status,
        lag_choke  = lc.choke_ticks,
        lag_conf   = lc.real_conf
    }

    -- Update global dashboard snapshot (last resolved target)
    last_nn_conf    = nn_conf or 0
    last_pattern    = pattern and pattern.pattern or "none"
    last_lag_status = lc.status or "unknown"
    last_desync     = result.desync or 0
    last_source     = result.source or "none"

end

resolver_states.resolve_entity = resolve_entity

----------------------------------------------------------------
-- Resolver Loop (called every net_update_start)
----------------------------------------------------------------

client.set_event_callback("net_update_start", function()
    if not ui.get(resolver_master) then return end

    local enemies = entity.get_players(true)
    for i = 1, #enemies do
        resolve_entity(enemies[i])
    end
end)

----------------------------------------------------------------
-- Training Tick (Part 3)
----------------------------------------------------------------

client.set_event_callback("net_update_end", function()
    if not ui.get(resolver_master) then return end
    resolver_states.train_nn()
end)

----------------------------------------------------------------
-- Debug Rendering Helpers
----------------------------------------------------------------

local function draw_text(x, y, r, g, b, a, text)
    renderer.text(x, y, r, g, b, a, "", 0, text)
end

local function draw_debug_for_entity(ent, y_offset)
    local state = resolver_states[ent]
    if not state or not state.resolved then return end

    local res = state.resolved
    local pattern = res.pattern or "none"
    local conf = string.format("%.2f", res.nn_conf or 0)
    local head_bias = res.head_bias ~= nil and string.format("%.2f", res.head_bias) or "0.00"

    local name = entity.get_player_name(ent) or ("ent " .. ent)
    local lag_status = res.lag_status or "unknown"
    local lag_choke  = res.lag_choke or 0
    local lag_conf   = string.format("%.2f", res.lag_conf or 0)

    local lines = {
        "Resolver V2 Debug",
        "Target: " .. name,
        "Source: " .. res.source,
        "NN Conf: " .. conf,
        "Resolved Desync: " .. string.format("%.1f", res.desync),
        "Head Bias: " .. head_bias,
        "Pattern: " .. pattern,
        "Lagcomp: " .. lag_status .. " | choke=" .. lag_choke .. " | conf=" .. lag_conf
    }


    local x = 20
    local y = y_offset

    for i = 1, #lines do
        draw_text(x, y, 200, 200, 255, 255, lines[i])
        y = y + 12
    end
    -- Simple lagcomp confidence bar
    local bar_x = 200
    local bar_y = y_offset - 4
    local bar_w = 80
    local bar_h = 4

    local lc_val = res.lag_conf or 0
    local fill_w = bar_w * lc_val

    -- Background
    renderer.rectangle(bar_x, bar_y, bar_w, bar_h, 30, 30, 60, 180)

    -- Fill (green when high, yellow mid, red low)
    local r, g, b = 255, 80, 80
    if lc_val > 0.7 then
        r, g, b = 80, 255, 120
    elseif lc_val > 0.4 then
        r, g, b = 230, 200, 80
    end

    renderer.rectangle(bar_x, bar_y, fill_w, bar_h, r, g, b, 220)

    return y
end

----------------------------------------------------------------
-- Debug Overlay Callback
----------------------------------------------------------------

client.set_event_callback("paint", function()
    if not ui.get(resolver_master) then return end
    if not ui.get(resolver_debug) then return end

    local enemies = entity.get_players(true)
    local y = 200

    for i = 1, #enemies do
        local new_y = draw_debug_for_entity(enemies[i], y) 
            if new_y then y = new_y + 20 
        end
    end
end)

----------------------------------------------------------------
-- Frost Dashboard
----------------------------------------------------------------

local dash_alpha = 0
local dash_pulse = 0

client.set_event_callback("paint", function()
    if not ui.get(resolver_master) then return end
    if not ui.get(dashboard_toggle) then return end

    local x, y = 20, 300
    local w, h = 260, 120

    -- Frosted background animation
    dash_pulse = dash_pulse + globals.frametime() * 2
    dash_alpha = 120 + math.sin(dash_pulse) * 40

    renderer.rectangle(x, y, w, h, 40, 40, 60, dash_alpha)

    renderer.text(x + 10, y + 10, 180, 200, 255, 255, "Frost Dashboard")
    renderer.text(x + 10, y + 30, 255, 255, 255, 255, "NN Conf: " .. string.format("%.2f", last_nn_conf or 0))
    renderer.text(x + 10, y + 45, 255, 255, 255, 255, "Pattern: " .. (last_pattern or "none"))
    renderer.text(x + 10, y + 60, 255, 255, 255, 255, "Lagcomp: " .. (last_lag_status or "unknown"))
    renderer.text(x + 10, y + 75, 255, 255, 255, 255, "Desync: " .. string.format("%.1f", last_desync or 0))
    renderer.text(x + 10, y + 90, 255, 255, 255, 255, "Source: " .. (last_source or "none"))
end)

----------------------------------------------------------------
-- Cleanup Logic
----------------------------------------------------------------

local CLEANUP_INTERVAL = 2.0

client.set_event_callback("net_update_end", function()
    local now = globals.curtime()
    if now - last_cleanup_time < CLEANUP_INTERVAL then
        return
    end
    last_cleanup_time = now

    -- Clean stale prediction cache
    for ent, data in pairs(prediction_cache) do
        if now - data.time > 0.5 then
            prediction_cache[ent] = nil
        end
    end

    -- Clean stale resolver states
    for ent, data in pairs(resolver_states) do
        if type(ent) == "number" and not entity.is_alive(ent) then
            resolver_states[ent] = nil
        end
    end

    -- Clean stale pattern data
    for ent, data in pairs(aa_patterns) do
        if type(ent) == "number" and not entity.is_alive(ent) then
            aa_patterns[ent] = nil
        end
    end
end)

----------------------------------------------------------------
-- Persistence: Behavior Profiles & Experiences
----------------------------------------------------------------

local function load_behavior_profiles()
    if not readfile or not json then return end
    local ok, content = pcall(readfile, BEHAVIOR_PROFILE_FILE)
    if not ok or not content or content == "" then return end

    local ok2, data = pcall(json.parse, content)
    if not ok2 or type(data) ~= "table" then return end

    behavior_profiles = data
end

local function save_behavior_profiles()
    if not writefile or not json then return end

    local ok, encoded = pcall(json.stringify, behavior_profiles)
    if not ok or not encoded then return end

    pcall(writefile, BEHAVIOR_PROFILE_FILE, encoded)
end

local function load_experiences_from_disk()
    if not readfile or not json then return end
    local ok, content = pcall(readfile, EXPERIENCE_LOG_FILE)
    if not ok or not content or content == "" then return end

    local ok2, data = pcall(json.parse, content)
    if not ok2 or type(data) ~= "table" then return end

    experience_log = data
end

local function save_experiences_to_disk()
    if not writefile or not json then return end

    -- Clamp size
    if #experience_log > MAX_EXPERIENCES_ON_DISK then
        local excess = #experience_log - MAX_EXPERIENCES_ON_DISK
        for i = 1, excess do
            table.remove(experience_log, 1)
        end
    end

    local ok, encoded = pcall(json.stringify, experience_log)
    if not ok or not encoded then return end

    pcall(writefile, EXPERIENCE_LOG_FILE, encoded)
end

----------------------------------------------------------------
-- Pretraining Logic
----------------------------------------------------------------

local function pretrain_from_experiences(max_time_sec)
    if not experience_log or #experience_log == 0 then return end
    if not globals or not globals.curtime then return end

    local start_time = globals.curtime()
    local i = 1
    while i <= #experience_log do
        local e = experience_log[i]
        if e and e.features and e.target and e.reward ~= nil then
            enhanced_nn.add_experience(e.features, e.target, e.reward, e.hit_success or false)
        end

        if i % 32 == 0 then
            local batch = enhanced_nn.sample_batch()
            if batch then
                enhanced_nn.train(batch)
            end

            if globals.curtime() - start_time > max_time_sec then
                break
            end
        end

        i = i + 1
    end

    -- After pretraining, save current weights
    enhanced_nn.save()
end

-- Initialize persistent data on script load
load_behavior_profiles()
load_experiences_from_disk()
pretrain_from_experiences(2.5) -- ~2.5 seconds budget

----------------------------------------------------------------
-- Shutdown Save
----------------------------------------------------------------
client.set_event_callback("shutdown", function()
    enhanced_nn.save()
    save_behavior_profiles()
    save_experiences_to_disk()
end)
